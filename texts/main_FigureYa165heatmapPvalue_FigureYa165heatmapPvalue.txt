FigureYa165heatmapPvalue
FigureYa165heatmapPvalue
Author(s)
: Xiaofan Lu
Reviewer(s)
: Ying Ge, Junyi Shen
Date
: 2025-09-22
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
Requirement Description
热图展示亚型表达谱，并给出表达谱组间比较p值。 A heatmap displays
subtype expression profiles and provides p-values for intergroup
comparisons.
出自
https://www.frontiersin.org/articles/10.3389/fonc.2019.01038
From
https://www.frontiersin.org/articles/10.3389/fonc.2019.01038
Figure 1. Expression of m6A RNA methylation regulators in gliomas
with different clinicopathological features. (A-D) The expression levels
of thirteen m6A RNA methylation regulators in gliomas with different WHO
grades.
应用场景
Application Scenario
针对两组或多组样本，做组间差异检验，提供4种常用非参或参数检验法：
Test for intergroup differences between two or more groups of samples.
Four common nonparametric or parametric tests are provided:
两组，参数检验”t.test”, 非参数检验”wilcox”
多组，参数检验”anova”, 非参数检验”kruskal”
For two groups, use the parametric test “t.test” and the
nonparametric test “wilcox”
For multiple groups, use the parametric test “anova” and the
nonparametric test “kruskal”
用热图展示亚型表达谱，并给出每个基因对应的表达谱组间比较p值。 Display
subtype expression profiles using a heatmap and provide p-values for
intergroup comparisons of expression profiles for each gene.
环境设置
Environment Setup
source("install_dependencies.R")
Load the package
library(stringr)
library(pheatmap)
library(gplots)
library(grid)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 # Display English error messages
options(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factors
加载自定义函数 Load a custom function
# 显示进程
# Display progress
display.progress = function (index, totalN, breakN=20) {
  
  if ( index %% ceiling(totalN/breakN)  ==0  ) {
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
  
} 

# 计算组间统计差异
# Calculate statistical differences between groups
cross_subtype_compr <- function(expr = NULL,
                                subt = NULL,
                                subt.label = "Subtype",
                                two_sam_compr_method = "wilcox",
                                multi_sam_compr_method = "kruskal",
                                res.path = NULL) {
  
  if (!is.element(two_sam_compr_method, c("t.test", "wilcox"))) {stop("Two samples comparison should be t.test or wilcox!\n") }
  if (!is.element(multi_sam_compr_method, c("anova", "kruskal"))) {stop("multiple samples comparison should be kruskal or anova!\n") }
  
  subt.name <- unique(subt[,subt.label])
  n.subt <- length(subt.name)
  if(n.subt < 2) {stop("The number of subtype should be greater than 2!\n")}
  
  comprTab <- NULL
  
  # 两个亚型且为非参数检验
  # Two subtypes and a non-parametric test 
  if(n.subt == 2 & two_sam_compr_method == "wilcox") {
    for (i in 1:nrow(expr)) {
      display.progress(index = i,totalN = nrow(expr))
      tmp1 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[1]),,drop = F])])
      tmp2 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[2]),,drop = F])])
      wt <- wilcox.test(tmp1,tmp2)
      comprTab <- rbind.data.frame(comprTab,
                                   data.frame(gene = rownames(expr)[i],
                                              nominal.p.value = wt$p.value,
                                              stringsAsFactors = F),
                                   stringsAsFactors = F)
    }
  }
  
  # 两个亚型且为参数检验
  # Two subtypes and a non-parametric test
  if(n.subt == 2 & two_sam_compr_method == "t.test") {
    for (i in 1:nrow(expr)) {
      display.progress(index = i,totalN = nrow(expr))
      tmp1 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[1]),,drop = F])])
      tmp2 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[2]),,drop = F])])
      tt <- t.test(tmp1,tmp2)
      comprTab <- rbind.data.frame(comprTab,
                                   data.frame(gene = rownames(expr)[i],
                                              nominal.p.value = tt$p.value,
                                              stringsAsFactors = F),
                                   stringsAsFactors = F)
    }
  }
  
  # 多个亚型且为非参数检验
  # Two subtypes and a parametric test 
  if(n.subt > 2 & multi_sam_compr_method == "kruskal") {
    for (i in 1:nrow(expr)) {
      display.progress(index = i,totalN = nrow(expr))
      tmp.list <- list()
      for (n in 1:n.subt) {
        tmp.list[[n]] <- data.frame(value = as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[n]),,drop = F])]),
                                    subt = subt.name[n],
                                    stringsAsFactors = F)
      }
      tmp <- do.call(rbind,tmp.list)
      kt <- kruskal.test(value ~ subt,data = tmp)
      comprTab <- rbind.data.frame(comprTab,
                                   data.frame(gene = rownames(expr)[i],
                                              nominal.p.value = kt$p.value,
                                              stringsAsFactors = F),
                                   stringsAsFactors = F)
    }
  }
  
  # 多个亚型且为参数检验
  # Multiple subtypes and non-parametric test 
  if(n.subt > 2 & multi_sam_compr_method == "anova") {
    for (i in 1:nrow(expr)) {
      display.progress(index = i,totalN = nrow(expr))
      tmp.list <- list()
      for (n in 1:n.subt) {
        tmp.list[[n]] <- data.frame(value = as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[n]),,drop = F])]),
                                    subt = subt.name[n],
                                    stringsAsFactors = F)
      }
      tmp <- do.call(rbind,tmp.list)
      at <- summary(aov(value ~ subt,data = tmp))
      comprTab <- rbind.data.frame(comprTab,
                                   data.frame(gene = rownames(expr)[i],
                                              nominal.p.value = at[[1]][1,5],
                                              stringsAsFactors = F),
                                   stringsAsFactors = F)
    }
  }
  
  # 调整p值
  # Adjust p-value
  comprTab$adjusted.p.value = p.adjust(comprTab$nominal.p.value,method = "BH")
  # 按p值排序
  # Sort by p-value
  #comprTab <- comprTab[order(comprTab$adjusted.p.value, decreasing = F),] 
  
  write.table(comprTab,file.path(res.path,"comprTab.txt"),sep = "\t",row.names = F,quote = F)
  return(comprTab)
}
输入文件
Input File
如果你自己的数据已经整理成easy_input
文件的格式，就直接跳到“差异表达分析”。
If your data has already been organized into easy_input
file
format, skip directly to “Differential Expression Analysis.”
输入文件的下载
Download Input File
基因表达矩阵，CGGA.mRNA_array_301_gene_level.20191128.txt，每行一个基因，每列一个sample。从CGGA下载：
Expression
Data (gene level)
，解压； Gene expression matrix,
CGGA.mRNA_array_301_gene_level.20191128.txt, one gene per row, one
sample per column. Download
Expression
Data (gene level)
from CGGA and unzip it.
分组信息，CGGA.mRNA_array_301_clinical.20191128.txt，至少包含CGGA_ID和Grade两列，这里用Grade为LGG和GBM分组。从CGGA下载：
Clinical
Data
，解压； Grouping information,
CGGA.mRNA_array_301_clinical.20191128.txt, contains at least two
columns: CGGA_ID and Grade. Here, Grade is used to group LGG and GBM.
Download
Clinical
Data
from CGGA and unzip.
读取基因表达矩阵
Read the gene expression matrix
#exp_data <- read.table("CGGA.mRNA_array_301_gene_level.20191128.txt", header=T, row.names=1, sep="\t")
# 为方便传输，只保留小数点后1位
# For ease of transmission, only one decimal place is retained.
#write.csv(round(exp_data,1), "easy_input_expr_ori.csv", quote = F)
exp_data <- read.csv("easy_input_expr_all.csv", row.names = 1)
exp_data[1:3,1:3]
读取分组信息
Read group information
用到两列：CGGA_ID和Grade Use two columns: CGGA_ID and Grade
clinical_data <- read.table("CGGA.mRNA_array_301_clinical.20191128.txt", header=T, sep="\t")
clinical_data <- clinical_data[!is.na(clinical_data$Grade), ]
clinical_data[1,]
Subtype <- data.frame(Subtype = clinical_data$Grade)
row.names(Subtype) <- clinical_data$CGGA_ID
# 保存到文件，便于模仿格式
# Save to a file for easy formatting
write.csv(Subtype, "easy_input_group.csv", quote = F)
提取感兴趣的基因的表达矩阵
Extract the expression matrix of the gene of interest
# 读取基因名
# Read gene name
mygene <- read.table("easy_input_gene.txt")$V1

# 获取感兴趣的基因表达谱
# Obtain expression profile of the gene of interest
mygene_data <- exp_data[mygene, ]
mygene_data[1:5, 1:5]
# 保存到文件
write.csv(mygene_data, "easy_input_expr.csv", quote = F)
差异表达分析
Differential expression analysis
# 用全部基因来画
# Plot all genes
n.show_top_gene <- nrow(mygene_data)
# 或者取top 20个基因来画
# Or plot the top 20 genes
#n.show_top_gene <- 20 

# 按分组排序
# Sort by group
subt.order <- Subtype[order(Subtype$Subtype),,drop = F]
indata <- mygene_data[comprTab$gene[1:n.show_top_gene],rownames(subt.order)]
开始画图
Start plotting
# 数据标准化和边界设置
# Normalize data and set boundaries
plotdata <- t(scale(t(indata)))
plotdata[plotdata > 2] <- 2
plotdata[plotdata < -2] <- -2

# 调整行名
# Adjust row names
blank <- "    " # 行名和p值之间的间隔 # Spacing between row names and p-values
p.value <- comprTab$adjusted.p.value[1:n.show_top_gene]
sig.label <- ifelse(p.value < 0.001,"****",
                    ifelse(p.value < 0.005,"***",
                           ifelse(p.value < 0.01,"**",
                                  ifelse(p.value < 0.05,"*",""))))
p.label <- formatC(p.value, # 将p值变成保留两位小数的科学计数法 # Convert p-values to scientific notation with two decimal places
                   format = "e",
                   digits = 2)

add.label <- str_pad(paste0(rownames(plotdata),sig.label), # 固定行名宽度并再右侧补齐" "
# Fix row name width and pad to the right. " "
                     max(nchar(paste0(rownames(plotdata),sig.label))), 
                     side = "right")

annCol <- subt.order # 获得排序后的亚型注释信息，这里只有一个变量需要注释
# Get the sorted subtype annotation information. Here, only one variable needs to be annotated.
colnames(annCol)[1] <- paste(str_pad(colnames(annCol)[1], # 注释列名补上"P-value"，宽度和刚才一致
# Add "P-value" to the annotation column name. The width is the same as before.
                                     max(nchar(paste0(rownames(plotdata),sig.label))), 
                                     side = "right"),
                             "P-value",
                             sep = blank)

annColors <- list(c("WHO II"="lightblue", "WHO III"="darkgreen", "WHO IV"="pink")) # 如果有多个变量要注释颜色请补充c() # If there are multiple variables to be annotated with color, please add c()
names(annColors) <- colnames(annCol)[1] # 如果有多个变量要注释颜色请补充每张list的name
# If there are multiple variables to be annotated with color, please add the name of each list

# 绘制热图
# Draw a heat map
pheatmap(cellheight = 15, cellwidth = 1,
         mat = plotdata, # 输入数据 # Input data
         scale = "none", # 不标准化因为数据已经被标准化 # Not normalized because the data has been normalized
         annotation_col = annCol, # 列注释信息 # column annotation information
         annotation_colors = annColors, # 列注释对应的颜色 # color corresponding to column annotations
         cluster_cols = F, # 列不聚类 # columns are not clustered
         cluster_rows = F, # 行不聚类 # rows are not clustered
         show_colnames = F, # 不显示列名 # do not display column names
         show_rownames = T, # 显示基因名 # display gene names
         #annotation_legend = F, # 不显示图例 # do not display legends
         labels_row = paste(add.label, p.label, sep=blank), # 自定义样本名义blank作间隔 # custom sample name blank as interval
         fontfamily = "mono", # 关键，使用fixed font而不是proportional font # key, use fixed font instead of proportional font
         gaps_col = c(173), # 根据自己的数据设置空白间隔的位置 # set the position of the blank interval according to your own data
         filename = "heatmapPvalue.pdf")
后期处理
Post-Processing
输出的pdf文件是矢量图，可使用Illustrator等矢量图工具打开，仿照例文将各个亚型的名字添加在annotation
bar的上方。 The output PDF file is a vector image. You can open it in a
vector graphics tool like Illustrator and add the names of each subtype
above the annotation bar, following the example text.
Session Info
sessionInfo()