FigureYa128Prognostic
FigureYa128Prognostic
Author(s)
: Xiaofan Lu, Taojun Ye
Reviewer(s)
: Ying Ge
Date
: 2025-09-30
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
文章中的那7个基因咋选出来的？
出自
https://clincancerres.aacrjournals.org/content/18/21/6001
这里有文章解读：
https://www.jianshu.com/p/58eab0d8ac22?from=singlemessage&isappinstalled=0
Requirement description
How were the 7 genes selected in the article?
From<
https://clincancerres.aacrjournals.org/content/18/21/6001
>
Here is an article interpretation:<
https://www.jianshu.com/p/58eab0d8ac22?from=singlemessage&isappinstalled=0
>
应用场景
找marker基因。
通过迭代LASSO产生“共识”下被保留的基因，进一步通过AUC选择与生存相关的最小基因组合。
小伙伴跟作者间的问答记录：
问：迭代lasso的原理是什么？
答：lasso在允许的时候高度依赖种子，因为你需要交叉验证，而交叉验证的过程是随机选取样本的。所以一旦你更换了种子，最优lambda就会改变，最终得到的特征就会改变。共识就是在多次运行lasso（不依赖种子）后，那么高频次被保留下的特征，可以认为是对感兴趣话题最有影响的。因为如果我运行500次，A特征出现了300次，和B特征出现了30次，它们的重要程度肯定是不同的。不是选共同的，是对频次排序，这是我的理解。频次的顺序代表了这些特征的影响程度，然后依次把这些特征纳入cox模型，当AUROC达到峰值的时候停止纳入，此时模型最优，并且所含特征最少。
Application scenarios
Find marker genes.
By iterating LASSO to generate genes that are retained under the
consensus, the minimum gene combination related to survival is further
selected through AUC.
Q&A record between the friend and the
author:
Q: What is the principle of iterating lasso?
Answer: lasso heavily relies on seeds when allowed, as you need cross
validation, which involves randomly selecting samples. So once you
change the seed, the optimal lambda will change, and the final features
obtained will change. Consensus is that after running lasso multiple
times (without relying on seeds), the high-frequency features preserved
can be considered the most influential on the topic of interest. Because
if I run it 500 times and feature A appears 300 times and feature B
appears 30 times, their importance levels will definitely be different.
It’s not about choosing common ones, it’s about sorting by frequency,
that’s my understanding. The order of frequency represents the degree of
influence of these features, and then these features are sequentially
included in the Cox model. When the AUROC reaches its peak, the
inclusion stops, and the model is optimal with the least number of
features.
环境设置
Environment settings
source("install_dependencies.R")
library(survival)
library(survivalROC)
# 设置环境语言为英文，确保报错信息为英文
# Set environment language to English to ensure error messages are in English
Sys.setenv(LANGUAGE = "en") 

# 禁止字符串自动转换为因子，提高数据处理稳定性
# Disable automatic conversion of strings to factors for more stable data processing
options(stringsAsFactors = FALSE)
自定义函数
Custom functions
# 显示进程
# Display progress
display.progress = function (index, totalN, breakN=20) {
  # index: 当前迭代索引
  # index: Current iteration index
  # totalN: 总迭代次数
  # totalN: Total number of iterations
  # breakN: 控制进度显示的频率，将总次数分成breakN份显示
  # breakN: Controls the frequency of progress display, divides total iterations into breakN parts
  
  if ( index %% ceiling(totalN/breakN)  ==0  ) {
    # 当迭代次数达到指定间隔时显示进度百分比
    # Display progress percentage when current iteration reaches specified interval
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
}    

# lasso回归
# LASSO regression for survival analysis
surv_lasso <- function(iter.times = NULL, surv.obj = NULL, expr.obj = NULL, nfolds = 10, alpha = 1, family = "cox") {
  # iter.times: pblapply的传入参数，用于迭代次数
  # iter.times: Input parameter for pblapply, used for iteration count
  # surv.obj: surv对象，由Surv()函数得到；
  # surv.obj: Survival object created by Surv() function
  # expr.obj: 表达谱对象，注意行为特征，列为样本
  # expr.obj: Expression profile object, note rows are features, columns are samples
  # nfolds：筛选最优lambda时的交叉验证次数，默认为10
  # nfolds: Number of cross-validation folds for selecting optimal lambda, default is 10
  # alpha： 默认为1表示LASSO回归
  # alpha: Default is 1, representing LASSO regression
  # family： 默认为"cox"
  # family: Default is "cox" for Cox proportional hazards model

  cvfit = cv.glmnet(x = t(as.matrix(expr.obj)), 
                    y = surv.obj, 
                    nfolds = nfolds, # 10折交叉验证选取最优lambda
                    # 10-fold cross-validation to select optimal lambda
                    alpha = alpha, # alpha = 1 意味着 lasso
                    # alpha = 1 indicates LASSO regression
                    family = family) # 依赖cox模型
                    # Based on Cox proportional hazards model
  
  # 取出最优lambda对应的系数
  # Extract coefficients corresponding to optimal lambda
  myCoefs <- coef(cvfit, s="lambda.min");
  lasso_fea <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )] 
  # Extract non-zero features (those retained by LASSO)
  
  return(lasso_fea)
}
输入文件的准备
如果你的文件已经整理成easy_input_expr.csv和easy_input_cli.csv的格式，就可以跳过这步，直接进入“筛选基因”。
Preparation of input files
If your file has already been organized into the formats of
easy_input-expr.csv and easy_input_cli.csv, you can skip this step and
go directly to “Filter Genes”.
输入文件的下载
需要表达矩阵和带followup的临床数据。
COAD_TPM.txt，表达矩阵，这里用的是COAD的TPM。从XENA
pan-cancer表达数据中提取某种癌症的TPM的方法可参考FigureYa56Immune_inflitration；或者直接下载某个癌症的表达矩阵，方法可参考FigureYa23count2TPM、FigureYa34count2FPKMv2。
clinical_PANCAN_patient_with_followup.tsv，带followup的临床信息，从这个页面下载
https://gdc.cancer.gov/about-data/publications/PanCanStemness-2018
，下载地址：
https://api.gdc.cancer.gov/data/0fc78496-818b-4896-bd83-52db1f533c5c
Download of input files
Need to express matrix and clinical data with followup.
COAD_TPM.txt， The expression matrix used here is COAD’s TPM. The
method for extracting TPM of a certain cancer from XENA pan cancer
expression data can refer to FigureYa56Immune_infliction; Alternatively,
you can directly download the expression matrix of a certain cancer
using the methods shown in FigureYa23count2TPM and
FigureYa34count2FPKMv2.
clinical_PANCAN_patient_with_followup.tsv， Download clinical
information with follow up from this page<
https://gdc.cancer.gov/about-data/publications/PanCanStemness-2018
>Download link:<
https://api.gdc.cancer.gov/data/0fc78496-818b-4896-bd83-52db1f533c5c
>
#读取表达矩阵
# Read expression matrix
expr <- read.table("COAD_TPM.txt",sep = "\t",check.names = F,stringsAsFactors = F,header = T,row.names = 1)

#根据TCGA的sample ID编码提取肿瘤样本
# Extract tumor samples based on TCGA sample ID encoding
expr <- expr[,substr(colnames(expr),11,12) == "01"] 
# 01 indicates tumor samples
colnames(expr) <- substr(colnames(expr),1,9)  
# Simplify sample names to first 9 characters
expr[1:3,1:3]
#读取临床数据
# Read clinical data
Sinfo <- read.table("clinical_PANCAN_patient_with_followup.tsv",sep = "\t",check.names = F,header = T,stringsAsFactors = F,quote = "")
unique(Sinfo$acronym)  # 查看包含的癌症类型
# Check included cancer types
Sinfo <- Sinfo[which(Sinfo$acronym %in% "COAD"),]  
# Keep only colon adenocarcinoma (COAD) data
rownames(Sinfo) <- paste0("COAD-",substr(Sinfo$bcr_patient_barcode,9,12))  # 构建样本ID
# Construct sample IDs
Sinfo[1:3,1:3]
dim(Sinfo)
输入数据预处理
# 生存数据预处理（请根据自己的数据特点修改）###
# Survival data preprocessing (modify according to your data characteristics) ###
Sinfo <- Sinfo[,c("vital_status","days_to_death","days_to_last_followup")]  # 选取需要的生存相关列
# Select survival-related columns

Sinfo$OS <- ifelse(Sinfo$vital_status == "Dead", 1,0)  # 将生存状态转换为二元数值变量(1=死亡,0=存活)
# Convert vital status to binary variable (1=Dead, 0=Alive)

Sinfo$OS.time <- ifelse(grepl("Not", Sinfo$days_to_death), Sinfo$days_to_last_followup, Sinfo$days_to_death)  # 根据两个变量生成最终生存时间
# Generate overall survival time based on death or last follow-up time

Sinfo <- Sinfo[-grep("Dis", Sinfo$OS.time), ]  # 移除包含无效生存时间的样本
# Remove samples with invalid survival time

Sinfo$OS.time <- as.numeric(Sinfo$OS.time)  # 转换生存时间为数值型
# Convert survival time to numeric type

Sinfo <- Sinfo[Sinfo$OS.time > 0,]  # 移除生存时间为0的无效样本
# Remove samples with survival time <= 0

Sinfo[1:3,1:4]  # 查看处理后的数据前几行
# 筛选既有表达矩阵又有随访信息的样本
# Filter samples with both expression data and follow-up information
com_sam <- intersect(rownames(Sinfo),colnames(expr))  # 找出交集样本

# 产生最终数据
# Generate final datasets
expr <- expr[,com_sam]  # 筛选表达矩阵
# Filter expression matrix
Sinfo <- Sinfo[com_sam,]  # 筛选临床数据
# Filter clinical data

#保存到文件
# Save to files
write.csv(round(expr, 1), "easy_input_expr.csv", quote = F)  # 保存表达矩阵，保留1位小数
# Save expression matrix with 1 decimal place
write.csv(Sinfo, "easy_input_cli.csv", quote = F)  # 保存临床数据
# Save clinical data
筛选基因
# 读取预处理后的表达矩阵和临床数据
# Read preprocessed expression matrix and clinical data
expr <- read.csv("easy_input_expr.csv", check.names = F, row.names = 1)
expr[1:3,1:3]  # 查看数据前几行几列
Sinfo <- read.csv("easy_input_cli.csv", check.names = F, row.names = 1)
Sinfo[1:3,1:3]  # 查看数据前几行几列
# 过滤出方差>var.cutoff的基因
# Filter genes with variance > var.cutoff
var.cutoff <- 5  # 例文中为GEO数据，阈值设为0.2
# Example uses 0.2 for GEO data, here using 5 for TCGA data
var <- apply(expr, 1, sd)  # 计算每个基因的标准差
# Calculate standard deviation for each gene
expr.filtered <- expr[var > var.cutoff,]  # 因为这里是TCGA数据，所以设置的大一些
# Keep genes with variance exceeding cutoff

# 过滤出与总生存(OS)有关的基因
# Filter genes associated with overall survival (OS)
cox.cutoff <- 0.1  # 例文中阈值设为0.5
# Example uses 0.5, here using 0.1
Coxoutput.OS <- NULL  # 初始化结果数据框
# Initialize results data frame

# 遍历筛选后的基因进行单变量Cox回归分析
# Iterate through filtered genes for univariate Cox regression
for (i in 1:nrow(expr.filtered)) {
  display.progress(index = i,totalN = nrow(expr.filtered))  # 显示进度
  # Display progress
  
  # 产生临时变量存储生存以及变量表达值
  # Create temporary data frame with gene expression and survival data
  tmp <- data.frame(gene = as.numeric(expr.filtered[i,]),
                    OS.time = Sinfo[,"OS.time"],
                    OS = Sinfo[,"OS"],
                    stringsAsFactors = F)
  
  # 单变量Cox比例风险模型
  # Univariate Cox proportional hazards model
  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)
  coxSummary = summary(cox)
  
  # 生成Cox结果数据框，包括基因名，风险比，z值，Wald检验p值，以及HR置信区间
  # Generate Cox results data frame with gene name, hazard ratio, z-value, p-value, and CI
  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(expr.filtered)[i],
                                                        HR=as.numeric(coxSummary$coefficients[,"exp(coef)"]),
                                                        z=as.numeric(coxSummary$coefficients[,"z"]),
                                                        pvalue=as.numeric(coxSummary$coefficients[,"Pr(>|z|)"]),
                                                        lower=as.numeric(coxSummary$conf.int[,3]),
                                                        upper=as.numeric(coxSummary$conf.int[,4]),
                                                        stringsAsFactors = F),
                                stringsAsFactors = F)
}
write.table(Coxoutput.OS,"Coxoutput.OS.txt",sep = "\t",row.names = F,quote = F)  # 保存结果

### 根据cox.cutoff筛选基因
### Filter genes by cox.cutoff p-value
if(!identical(rownames(expr.filtered),Coxoutput.OS$gene)) {stop("Error! Gene name is mismatched!\n")}  # 确保基因名匹配
# Ensure gene names match between expression matrix and Cox results
surv.expr <- expr.filtered[Coxoutput.OS$pvalue < cox.cutoff,]  # 筛选p值小于阈值的基因
# Keep genes with p-value < cutoff
dim(surv.expr)  # 查看筛选后的基因数量
开始画图
用base plot画图
sessionInfo()