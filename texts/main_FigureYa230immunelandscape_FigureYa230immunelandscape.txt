FigureYa230ImmuneLandscape
FigureYa230ImmuneLandscape
Author(s)
: Xiaofan Lu
Date
: 2025-10-04
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
If you use circlize in published research, please cite:
Gu, Z. circlize implements and enhances circular visualization in R.
Bioinformatics 2014.
需求描述
我想实现一个多种算法的风险值和免疫细胞相关性热图（文中Figure 7）
Requirement Description
I would like to draw a heat map of risk value and immune cell
correlation for multiple algorithms (Figure 7 in the article)
出自
https://www.ijbs.com/v17p0702.htm
from
https://www.ijbs.com/v17p0702.htm
Figure 7. Heatmap for immune responses based on CIBERSORT, ESTIMATE,
MCPcounter, ssGSEA, and TIMER algorithms among high and low risk
group.
应用场景
多个热图画在一起。
例文绘制不同免疫富集分析得到结果的综合热图。
不仅限于免疫富集分析结果，还可以用于WGCNA、多组学分析结果的展示。
原文使用了pheatmap的方式对不同的算法做了行注释，我这里提供两种方法；
①原文的pheatmap::pheatmap展示
②采用ComplexHeatmap::pheatmap对不同算法采用不同颜色的热图，后垂直衔接热图展示
图中各种打分的计算方法可参考我们实现过的FigureYa：
计算CIBERSORT得分、ESTIMATE得分，可参考FigureYa211multiCohortImmSubtype
ssGSEA，可参考FigureYa71ssGSEA
TIMER，从网站下载TIMER数据可参考FigureYa234panImmune，用immunedeconv包进行TIMER打分可参考FigureYa264epiImmune
Application Scenarios
Multiple heat maps are drawn together.
In this example, a comprehensive heat map of the results obtained
from different immune enrichment analyses is plotted.
It is not limited to the results of immune enrichment analysis, but
can also be used to display the results of WGCNA and multi-omics
analysis.
The original article uses pheatmap to make line comments on different
algorithms, and I provide two methods here;
The original pheatmap: :p heatmap display
ComplexHeatmap: :p heatmap uses different colors for different
algorithms, and then vertically connects the heatmap to display
The calculation methods of various scores in the figure can be
referred to:
To calculate the CIBERSORT score and ESTIMATE score, see
FigureYa211multiCohortImmSubtype
ssGSEA, see FigureYa71ssGSEA
TIMER, for downloading TIMER data from the website, please refer to
FigureYa234panImmune, and for TIMER scoring with the immunedeconv
package, please refer to FigureYa264epiImmune
环境设置
Environment settings
source("install_dependencies.R")
library(RColorBrewer)
library(circlize)
library(gplots)
library(viridis)
library(oompaBase)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 # error messages are displayed in English
options(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor
自定义函数 Custom functions
standarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  
  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))
  if (!is.null(halfwidth)) {
    outdata[outdata>halfwidth]=halfwidth
    outdata[outdata<(-halfwidth)]= -halfwidth
  }
  return(outdata)
}
输入文件
easy_input.csv，画热图所需的数据。这里是多种算法获得的免疫浸润数据，每行一个sample，每列一种免疫细胞。可以灵活替换为其他需要画热图的数据，例如基因表达矩阵，那么这里的免疫细胞就替换为基因/蛋白质/通路等等。
热图自上而下分成一块一块的多个类，两种方式提供分类信息：
第一种方式是像
easy_input.csv
这样，分类跟细胞名之间用下划线
_
分隔
第二种方式是提供一个文件
easy_input_type.csv
，把细胞和分类（这里指不同算法）作为两列放进去，细胞名的顺序跟easy_input.csv里的细胞顺序一致。
easy_input_group.csv，分组信息和连续变量，用于画热图上方的注释。这里的连续变量是risk
score（根据它的大小为sample排序），分组信息是risk
type。读懂之后可以按照现有的格式添加更多行注释。
Input files
easy_input.csv, the data needed to draw a heat map. Here are the
immune infiltration data obtained by multiple algorithms, one sample per
row, one type of immune cell per column. It can be flexibly replaced
with other data that needs to be heatmapped, such as gene expression
matrix, then the immune cells here are replaced with
genes/proteins/pathways, etc.
The heatmap is divided into multiple classes from top to bottom, and
provides classification information in two ways:
The first way is to separate the classification from the cell name
with an underscore of ’_‘, like ’easy_input.csv’
The second way is to provide a file ‘easy_input_type.csv’ that puts
the cells and the classification (in this case) in two columns, and the
order of the cell names is the same as the order of the cells in the
easy_input.csv.
easy_input_group.csv, group information and continuous variables for
annotations above the heatmap. Here the continuous variable is the risk
score (sorted by its size) and the grouping information is the risk
type. Once you have read it, you can add more lines of comments in the
existing format.
# 加载热图数据
# Load heatmap data
hmdat <- read.csv("easy_input.csv",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
# 或许你的数据行列与此相反，就这样转置一下
# Maybe your data rows and columns are the opposite, so transpose them like this
#hmdat <- t(hmdat)

# 加载分组
# Load grouping
risk <- read.csv("easy_input_group.csv",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
rownames(risk) <- paste0(rownames(risk),"-01")
dim(hmdat)
hmdat[1:3,1:3]
dim(risk)
head(risk)
# 从easy_input_type.csv读取分类信息
# Read classification information from easy_input_type.csv
type <- read.csv("easy_input_type.csv", row.names = 1)
head(type)
# 取出共有样本更新数据
# Take out the common sample and update the data
comsam <- intersect(rownames(risk),rownames(hmdat))
hmdat <- hmdat[comsam,]
risk <- risk[comsam,,drop = F]
dim(hmdat)
# 拆分不同算法结果，获得类的名字
# Split the results of different algorithms to get the name of the class
#immMethod <- sapply(strsplit(colnames(hmdat),"_",fixed = T),"[",2) #用easy_input.csv列名里的算法信息 # Use the algorithm information in the easy_input.csv column name
immMethod <- type$Methods # 用easy_input_type.csv的算法那一列 # Use the easy_input_type.csv algorithm column
开始画图
1. 原文pheatmap版
Start drawing
1. Original pheatmap version
# 用pheatmap画图
# Draw with pheatmap
library(pheatmap)

# 定义颜色
# Define colors
methods.col <- brewer.pal(n = length(unique(immMethod)),name = "Paired")

# 创建注释
# 列注释，位于热图顶端
# Create annotations
# Column annotations, located at the top of the heatmap
annCol <- data.frame(RiskScore = scale(risk$riskScore),
                     RiskType = risk$risk,
                     # 以上是risk score和risk type两种注释，可以按照这样的格式继续添加更多种类的注释信息，记得在下面的annColors里设置颜色 # The above are risk score and risk type annotations, you can continue to add more kinds of annotation information according to this format, remember to set the color in the following annColors
                     row.names = rownames(risk),
                     stringsAsFactors = F)

# 行注释，位于热图左侧
# row annotation, located on the left side of the heatmap
annRow <- data.frame(Methods = factor(immMethod,levels = unique(immMethod)),
                     row.names = colnames(hmdat),
                     stringsAsFactors = F)

# 为各注释信息设置颜色
# Set the color for each annotation message
annColors <- list(Methods = c("TIMER" = methods.col[1], #行注释的颜色 # The color of the row comment
                              "CIBERSORT" = methods.col[2],
                              "CIBERSORT-ABS" = methods.col[3],
                              "QUANTISEQ" = methods.col[4],
                              "MCPCOUNTER" = methods.col[5],
                              "XCELL" = methods.col[6],
                              "EPIC" = methods.col[7]),
                  # 下面是列注释的颜色，可依此设置更多注释的颜色
                  # The following is the color of the column annotation, you can set the color of more annotations accordingly
                  "RiskScore" = greenred(64), 
                  "RiskType" = c("high" = "red","low" = "blue"))

# 数据标准化
# Data standardization
indata <- t(hmdat)
indata <- indata[,colSums(indata) > 0] # 确保没有富集全为0的细胞 # Make sure there are no cells with an enrichment of all 0s
plotdata <- standarize.fun(indata,halfwidth = 2)

# 样本按risk score排序
# Samples are sorted by risk score
samorder <- rownames(risk[order(risk$riskScore),])

# pheatmap绘图
# pheatmap plotting
pheatmap::pheatmap(mat = as.matrix(plotdata[,samorder]), # 标准化后的数值矩阵 # Normalized numerical matrix
                   border_color = NA, # 无边框色 # There is no border color
                   color = bluered(64), # 热图颜色为红蓝 # The heatmap color is red and blue
                   cluster_rows = F, # 行不聚类 # Rows are not clustered
                   cluster_cols = F, # 列不聚类 # Columns are not clustered
                   show_rownames = T, # 显示行名 # Show the Rowname
                   show_colnames = F, # 不显示列名 # Column names are not displayed
                   annotation_col = annCol[samorder,,drop = F], # 列注释 # Column Annotation
                   annotation_row = annRow, # 行注释 # Rows comments
                   annotation_colors = annColors, # 注释颜色 # Annotation colors
                   gaps_col = table(annCol$RiskType)[2], # 列分割 # Column splitting
                   gaps_row = cumsum(table(annRow$Methods)), # 行分割 # Line splitting
                   cellwidth = 0.8, # 元素宽度 # Element width
                   cellheight = 10, # 元素高度 # Element height
                   filename = "immune heatmap by pheatmap.pdf")
2. ComplexHeatmap衔接版
ComplexHeatmap里的pheatmap跟pheatmap里的pheatmap用法相同。
本质上还是用pheatmap画图，画颜色不同的多个热图，这样从颜色上就能一目了然地看出热图里的信息多了一层（分类信息，这里是不同算法），然后用ComplexHeatmap把多个热图拼在一起。
2. ComplexHeatmap Convergence Edition
The pheatmap in ComplexHeatmap is used in the same way as the
pheatmap in pheatmap.
In essence, we still use pheatmap to draw multiple heatmaps with
different colors, so that you can see at a glance that there is an extra
layer of information in the heatmap (classification information, here
are different algorithms), and then use ComplexHeatmap to stitch
together multiple heatmaps.
library(ComplexHeatmap)
# 最新版ComplexHeatmap好像有一些bug，使用里面的pheatmap函数会报错
# There seem to be some bugs in the latest version of ComplexHeatmap, and an error will be reported when using the pheatmap function in it
# 因此我们从脚本直接加载pheatmap函数
# So we load the pheatmap function directly from the script
source("pheatmap_translate.R") # 位于当前文件夹，出自ComplexHeatmap_2.7.9.tar.gz # Located in the current folder, from ComplexHeatmap_2.7.9.tar.gz

ht_opt$message = FALSE

# 创建注释
# Create annotations
annCol <- data.frame(RiskScore = scale(risk$riskScore),
                     RiskType = risk$risk,
                     row.names = rownames(risk),
                     stringsAsFactors = F)
annRow <- data.frame(row.names = colnames(hmdat),
                     Methods = factor(immMethod,levels = unique(immMethod)),
                     stringsAsFactors = F)

annColors <- list("RiskScore" = greenred(64),
                  "RiskType" = c("high" = "red","low" = "blue"))

# 数据标准化
# Data standardization
indata <- t(hmdat)
indata <- indata[,colSums(indata) > 0] # 确保没有富集全为0的细胞 # Make sure there are no cells with an enrichment of all 0s
plotdata <- standarize.fun(indata,halfwidth = 2)

# 样本按risk score排序
# Samples are sorted by risk score
samorder <- rownames(risk[order(risk$riskScore),])

# 拆分各算法的结果
# Split the results of each algorithm
plotdata1 <- plotdata[rownames(annRow[which(annRow$Methods == "TIMER"),,drop = F]),]
plotdata2 <- plotdata[rownames(annRow[which(annRow$Methods == "CIBERSORT"),,drop = F]),]
plotdata3 <- plotdata[rownames(annRow[which(annRow$Methods == "CIBERSORT-ABS"),,drop = F]),]
plotdata4 <- plotdata[rownames(annRow[which(annRow$Methods == "QUANTISEQ"),,drop = F]),]
plotdata5 <- plotdata[rownames(annRow[which(annRow$Methods == "MCPCOUNTER"),,drop = F]),]
plotdata6 <- plotdata[rownames(annRow[which(annRow$Methods == "XCELL"),,drop = F]),]
plotdata7 <- plotdata[rownames(annRow[which(annRow$Methods == "EPIC"),,drop = F]),]

# 分别画7次热图（参数基本同pheatmap里的pheatmap）
# Draw 7 heat maps separately (the parameters are basically the same as the pheatmap in the pheatmap)
hm1 <- pheatmap(mat = as.matrix(plotdata1[,samorder]),
                                border_color = NA,
                                #color = bluered(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                annotation_col = annCol[samorder,,drop = F],
                                annotation_colors = annColors,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "TIMER") # 为子热图的图例命名 # Name the legend of the subheatmap

hm2 <- pheatmap(mat = as.matrix(plotdata2[,samorder]),
                                border_color = NA,
                                color = greenred(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "CIBERSORT")

hm3 <- pheatmap(mat = as.matrix(plotdata3[,samorder]),
                                border_color = NA,
                                color = blueyellow(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "CIBERSORT-ABS")

hm4 <- pheatmap(mat = as.matrix(plotdata4[,samorder]),
                                border_color = NA,
                                color = bluered(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "QUANTISEQ")

hm5 <- pheatmap(mat = as.matrix(plotdata5[,samorder]),
                                border_color = NA,
                                color = inferno(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "MCPCOUNTER")

hm6 <- pheatmap(mat = as.matrix(plotdata6[,samorder]),
                                border_color = NA,
                                color = viridis(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "XCELL")

hm7 <- pheatmap(mat = as.matrix(plotdata7[,samorder]),
                                border_color = NA,
                                color = magma(64), 
                                cluster_rows = F,
                                cluster_cols = F,
                                show_rownames = T,
                                show_colnames = F,
                                cellwidth = 0.8,
                                cellheight = 10,
                                gaps_col = table(annCol$RiskType)[2],
                                name = "EPIC")

pdf("immune heatmap by ComplexHeatmap.pdf", width = 10,height = 20) # 保存前请注意RGUI里不能有任何显示的图像，否则不会pdf打不开 # Please note that there can be no displayed images in RGUI before saving, otherwise you will not be able to open the pdf
draw(hm1 %v% hm2 %v% hm3 %v% hm4 %v% hm5 %v% hm6 %v% hm7, # 垂直连接子热图 # Vertically connected with subheatmaps
     heatmap_legend_side = "bottom", # 热图注释放底部 # Heatmap note release bottom
     annotation_legend_side = "bottom") # 顶部注释放底部 # Top Note releases bottom
invisible(dev.off())
Session Info
sessionInfo()