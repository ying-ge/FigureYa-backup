FigureYa153ccgraph
FigureYa153ccgraph
Author(s)
: Chunhui Gao
Reviewer(s)
: Ying Ge, Junyi Shen
Date
: 2025-10-16
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
Requirement Description
用R从形式上复现原图。 Use R to reproduce the original figure in a
formal manner.
出自
https://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156
From
https://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156
Figure 1. Plot of all alterations detected by plasma next-generation
sequencing (n=210). Size of circles represents number of patients
identified with an alteration.
图的解析
Graph Analysis
例文用来展示基因上的 SNP/Indel/CNV 突变（多态性差异）。
例如，在TP53基因中发现了最多的多态性，包括 CNV 差异 SPLICE 8
个，单核苷酸位点差异 R273H
5个等。用点的大小表示差异，所以很容易发现常见的多态性差异。 The example
graph is used to display SNP/Indel/CNV mutations (polymorphic
differences) within a gene. For example, the TP53 gene has the most
polymorphisms, including 8 CNV differences (SPLICE) and 5 single
nucleotide variations (R273H). The size of the dots represents the
difference, making it easy to spot common polymorphic differences.
稍作观察便可发现，本图是一个“圆环套圆环”的布局，中心处在中央，下一级的项目分别处在外环。图中只有二环，如果要扩展成五环，多显示几个层次应该也不错。
A quick inspection reveals that this graph has a “ring within a circle”
layout, with the center at the center and the next-level items on the
outer rings. The diagram only has two rings. If you want to expand it to
five, showing more layers would be helpful.
原文用的是在线工具
The original article used
an online tool
推测原文是用这个工具画的：FuncTree
https://bioviz.tokyo/functree/
，能画出类似的图，用来展示基因组数据的关系。
It’s speculated that the original article used this tool: FuncTree
https://bioviz.tokyo/functree/
, which can create similar
diagrams for displaying relationships in genomic data.
缺点：输入数据格式复杂非常复杂。需要针对每一个点做有针对性的设置。感兴趣的小伙伴去尝试一下吧～
Disadvantages: The input data format is very complex. Targeted settings
are required for each point. If you’re interested, give it a try!
如何用R实现
How to Implement This in
R
tidytuesday
2019-11-12的图跟原图很像，代码
https://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r
，输入数据
https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv
。
I found that the 2019-11-12 graph from
tidytuesday
is
very similar to the original. The code is
https://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r
,
and the input data is
https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv
.
参考这套代码，用
ggraph
来画这个图。为此，花了几天时间仔细研究了
ggraph
包，写下了一篇长文：
一文读懂 ggraph
的使用
Using this code as a reference, I used
ggraph
to
draw this graph. To this end, I spent several days thoroughly studying
the
ggraph
package and wrote a lengthy article:
Understanding
ggraph in One Article
应用场景
Application Scenarios
展示层级结构。例如： Displaying hierarchical structures. For
example:
基因跟突变的关系，像例文那样；
上游调控因子调控下游基因的层级和强度；
宏基因组测序中发现的物种的丰度等信息。
The relationship between genes and mutations, as in the
example;
The level and strength of upstream regulatory factors regulating
downstream genes;
Information such as the abundance of species discovered in
metagenomic sequencing.
注：
Note:
周围点的大小只能对应正值或绝对值，不能展示正负区别；
不仅限于2层关系，还支持更多层级。
The size of surrounding points can only correspond to positive or
absolute values; it cannot display positive or negative
differences;
Not limited to two-level relationships; more levels are
supported.
环境设置
Environment Setup
source("install_dependencies.R")  # 确保依赖包已安装 # Ensure dependencies are installed
source(file = "gather_graph_node.R") # from ccgragh, https://github.com/gaospecial/ccgraph
source(file = "gather_graph_edge.R") # from ccgragh, https://github.com/gaospecial/ccgraph
library(clusterProfiler) # 用于功能富集分析 # For functional enrichment analysis
library(GOplot)          # 用于可视化基因本体分析结果 # For visualizing Gene Ontology analysis results
library(tidyverse)       # 用于数据操作和可视化的集合包 # A collection of packages for data manipulation and visualization
library(data.table)      # 用于高效的数据操作 # For efficient data manipulation
library(ggraph)          # 用于基于图形的可视化 # For graph-based visualizations
library(tidygraph)       # 用于处理图形数据 # For handling graph data

# 设置环境变量
# Set environment variables
Sys.setenv(LANGUAGE = "en")  # 显示英文报错信息 # Display error messages in English
options(stringsAsFactors = FALSE)  # 禁止字符型数据自动转换为因子型 # Prevent automatic conversion of character data to factors```
输入文件的获得
Obtaining the input file
如果你的数据已经整理成
very_easy_input.csv
的格式，就可以跳过这步，直接进入“输入文件预处理”。
If your data is already formatted as
very_easy_input.csv
,
you can skip this step and proceed directly to “Input File
Preprocessing.”
先用clusterProfiler做KEGG的GSEA，然后用例图的形式展示结果。 First,
use clusterProfiler to perform KEGG GSEA, then present the results using
a case diagram.
gsym.fc <- read.table("easy_input_rnk.txt", header = T)
dim(gsym.fc)
head(gsym.fc)

# 把gene symbol转换为ENTREZ ID
# Convert gene symbols to ENTREZ IDs
# 此处物种是人，其他物种的ID转换方法，请参考FigureYa52GOplot
# The species here is human. For ID conversion methods for other species, please refer to FigureYa52GOplot
gsym.id <- bitr(gsym.fc$SYMBOL, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#让基因名、ENTREZID、foldchange对应起来
# Align gene name, ENTREZ ID, and foldchange
gsym.fc.id <- merge(gsym.fc, gsym.id, by="SYMBOL", all=F)

#按照foldchange排序
# Sort by foldchange
gsym.fc.id.sorted <- gsym.fc.id[order(gsym.fc.id$logFC, decreasing = T),]

#获得ENTREZID、foldchange列表，做为GSEA的输入
# Obtain the ENTREZ ID and foldchange list as input for GSEA
id.fc <- gsym.fc.id.sorted$logFC
names(id.fc) <- gsym.fc.id.sorted$ENTREZID

#这一条语句就做完了KEGG的GSEA分析
# This single statement completes the KEGG GSEA analysis
kk <- gseKEGG(id.fc, organism = "hsa")
dim(kk)

# 把ENTREZ ID转为gene symbol，便于查看通路里的基因
# Convert the ENTREZ ID to a gene symbol to facilitate viewing genes within the pathway
kk.gsym <- setReadable(kk, 'org.Hs.eg.db', #物种
                      'ENTREZID')

# 可以用kk.gsym作为输入，用clusterProfiler画图
# Use kk.gsym as input to plot with clusterProfiler
# 用法看这里https://yulab-smu.github.io/clusterProfiler-book/chapter12.html
# See here for usage: https://yulab-smu.github.io/clusterProfiler-book/chapter12.html
# gsym.fc.l <- gsym.fc$logFC
# Names(gsym.fc.l) <- gsym.fc$SYMBOL
# Cnetplot(sortkk, foldChange = gsym.fc.l, circular = TRUE)

# 按照enrichment score从高到低排序，取前5（up）和后5（down）
# Sort by enrichment score, taking the top 5 (up) and bottom 5 (down)
# Sortkk <- kk.gsym[order(kk.gsym@result$enrichmentScore, decreasing = T),][c(1:5, (nrow(kk.gsym)-5):nrow(kk.gsym)),]
# 这里提取感兴趣的3个通路，数量太多拥挤的话不好看基因名
# Extract the three pathways of interest here. Too many gene names will make the gene names look cluttered.
sortkk <- kk.gsym[kk.gsym@result$Description %like% "DNA" | 
                    kk.gsym@result$Description %like% "cycle" | 
                    kk.gsym@result$Description %like% "p53",]

# 把富集分析结果整理为GOplot所需的格式
# Format the enrichment analysis results into the format required by GOplot
go <- data.frame(Category = "KEGG",
                 ID = sortkk$ID,
                 Term = sortkk$Description, 
                 Genes = gsub("/", ", ", sortkk$core_enrichment), 
                 adj_pval = sortkk$p.adjust)

# 基因变化倍数
# Fold change of genes
genelist <- data.frame(ID = gsym.fc.id$SYMBOL, logFC = gsym.fc.id$logFC)

# 把富集分析和倍数整合在一起
# Integrate the enrichment analysis and fold change
circ <- circle_dat(go, genelist)
head(circ)
# 可以用circ作为输入，用GOplot画图
# Use circ as input to plot with GOplot
# 用法看这里https://wencke.github.io/
# See here for usage: https://wencke.github.io/
# GOCircle(circ)

# 保存到文件
# Save to file
write.csv(circ[,c(3,5,6)],"very_easy_input.csv", quote = F, row.names = F)
输入文件预处理
Input file preprocessing
very_easy_input.csv，这里以上面的富集分析结果为例，展示通路和通路里的基因变化倍数FC。三列依次是通路-基因-倍数，可以自由替换成“应用场景”里其他需要展示的信息。
very_easy_input.csv, using the above enrichment analysis results as an
example, displays pathways and gene fold-change FC within them. The
three columns are pathway-gene-fold-change, which can be freely replaced
with other information required for the “application scenario.”
gene_special.txt，要突出显示的基因。第一列是基因名，第二列是类型（例如基因家族信息）。
gene_special.txt, genes to be highlighted. The first column is the gene
name, and the second column is the type (e.g., gene family
information).
df <- read.csv("very_easy_input.csv")
head(df)
geneSpecial <- read.table("gene_special.txt", header = T)
geneCol <- geneSpecial$Type
names(geneCol) <- geneSpecial$Gene
geneCol
图由两个部分组成，节点（node）和边（edge）。 A graph consists of two
components: nodes and edges.
要从上面的数据框中采集节点和边的信息。 Node and edge information will
be collected from the above data frame.
为此，我分别写了两个函数：
gather_graph_node()
和
gather_graph_edge()
来完成这一个任务（前面已加载）。 To
this end, I wrote two functions:
gather_graph_node()
and
gather_graph_edge()
to accomplish this task (previously
loaded).
这两个函数的参数设置借鉴了
treemap()
的实现方式。
df
：一个数据框
index
：一个索引项（分组项）
value
：要采集的数值
The parameter settings for these two functions are inspired by the
implementation of
treemap()
.
df
: A data frame
index
: An index item (grouping item)
value
: The value to be collected
为了确保
node.name
的唯一性，在图中使用了长名，而把原有的名字放在
node.short_name
中去了。 To ensure the uniqueness of
node.name
, the long name is used in the graph, and the
original name is placed in
node.short_name
.
node.level
则用来指示节点应该处于第几个圆环。
node.level
is used to indicate the ring level of the
node.
节点的属性统一以
node
作为前缀，而边的属性则以
edge
作为前缀。 Node attributes are prefixed with
node
, while edge attributes are prefixed with
edge
.
nodes <- gather_graph_node(df, index = c("term", "genes"), value = "logFC", root="all")
edges <- gather_graph_edge(df, index = c("term", "genes"), root = "all")
nodes <- nodes %>% mutate_at(c("node.level","node.branch"),as.character)
head(nodes, 10)
head(edges, 10)
# 把要突出显示的基因类型信息加到nodes里
# Add the gene type information to be highlighted to nodes
nodes$color <- "normal"
nodes[nodes$node.short_name %in% geneSpecial$Gene,]$color <- geneCol[nodes[nodes$node.short_name %in% geneSpecial$Gene,]$node.short_name]
nodes[nodes$node.short_name %in% geneSpecial$Gene,]
nodes$color <- factor(nodes$color, levels = unique(nodes$color))

# 有了节点和边的数据，使用 `tbl_graph()` 便可以得到一个图。
# With the node and edge data, use `tbl_graph()` to create a graph.
graph <- tbl_graph(nodes, edges)
开始画图
Start drawing the graph
自定义配色，直接出图
Customize the color scheme and plot directly
# 用 `ggraph` 出图 # Plot the graph using `ggraph`
gc <- ggraph(graph, layout = 'dendrogram', circular = TRUE) + 
  # 不画中心点，使用 filter 参数去掉 root（前面设置为"all"）节点及与其相连的边
  # Do not show the center node. Use the filter parameter to remove the root node (previously set to "all") and its connected edges.
  geom_edge_diagonal(aes(color = node1.node.branch,
                         filter=node1.node.level!="all"), 
                     alpha = 1/3,edge_width=1) + 
  geom_node_point(aes(size = node.size, 
                      color = node.branch,
                      filter=node.level!="all"), alpha = 1/3) + 
  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that the size is between the range.
  theme(legend.position = "none") + #不画图例 # Do not draw the legend.
  
  # 点和边的配色
# Coloring of points and edges.
  # 如果要改变边的配色，需要同时给边和点变色，否则会对应不上
# If you want to change the edge color, you need to change both the edge and the points at the same time; otherwise, the colors will not match.
  scale_edge_color_brewer(palette = "Set1") + #用?scale_color_brewer查看更多配色方案 # Use ?scale_color_brewer to view more color schemes
  scale_color_brewer(palette = "Set1") +
  
  # 添加周围注释文字，此处是基因名gene
# Add surrounding annotation text, here is the gene name
  geom_node_text(
    aes(
      x = 1.048 * x, #控制字跟点的距离 # Control distance between the word and the dot
      y = 1.048 * y, #控制字跟点的距离 # Control distance between the word and the dot
      label = node.short_name,
      angle = -((-node_angle(x, y) + 90) %% 180) + 90,
      filter = leaf,
      color = node.branch
      ),
    size = 6, hjust = 'outward') +
  
  # 添加内环文字，此处是通路名term
# Add inner ring text, here is the pathway name
  geom_node_text(
    aes(label=node.short_name,
        filter = !leaf & (node.level != "all"),
        color = node.branch),
    fontface="bold",
    size=6,
    family="sans"
  ) + 
  theme(panel.background = element_rect(fill = NA)) +
  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system

gc
ggsave("ccgraph_color.pdf", width = 14, height = 14)
在上面的图形中，线条的颜色由
geom_edge_diagonal(aes(color = node1.node.branch))
指定。
In the graph above, the line color is specified by
geom_edge_diagonal(aes(color = node1.node.branch))
.
node1.node.branch
指的是出发点（
node1
）的
node.branch
属性。如果要改变线条颜色，可以修改 nodes
表，添加一个属性（如
color
） ，然后在
geom_edge_diagonal()
中将其映射到
color
上即可。
node1.node.branch
refers to the
node.branch
attribute of the starting point
(
node1
). To change the line color, modify the nodes table,
add an attribute (e.g.,
color
), and then map it to
color
in
geom_edge_diagonal()
.
按例文配色，然后后期加背景色
Follow the example color scheme, then add a background color
later
保留中心点和连向中心点的线 ｜ keep the center node and the links to
it.
gc1 <- ggraph(graph, layout = 'dendrogram', circular = TRUE) + 
  #画连线 # Draw the lines
  geom_edge_diagonal(aes(color = node2.color), 
                     alpha = 0.5, #透明度 # Transparency
                     edge_width=2.5) + #连线的粗细 # Line thickness
  scale_edge_color_manual(values = c("#61C3ED","red","purple","darkgreen")) + #自定义颜色 # Custom color

  #画点 # Draw the points
  geom_node_point(aes(size = node.size), 
# Alpha = 1/3,
                  color = "#61C3ED") + #统一为淡蓝色 # Unify the color to light blue
  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that the size is between the range
  theme(legend.position = "none") + #不画图例 # Do not draw the legend
  
  # 添加周围注释文字，此处是基因名gene # Add surrounding annotation text, here is the gene name
  geom_node_text(
    aes(
      x = 1.05 * x, #控制字跟点的距离 # Control the distance between the word and the point
      y = 1.05 * y, #控制字跟点的距离 # Control the distance between the word and the point
      label = node.short_name,
      angle = -((-node_angle(x, y) + 90) %% 180) + 90,
      filter = leaf
      ),
    color="black", #统一为黑色字 # Uniformly use black text
    size = 6, hjust = 'outward') +
  
  # 添加内环文字，此处是通路名term # Add inner ring text, here is the pathway name
  geom_node_text(
    aes(label=node.short_name,
        filter = !leaf & (node.level != "all")
        ),
    color="black", #统一为黑色字 # Uniformly use black text
    fontface="bold",
    size=6,
    family="sans"
  ) + 
  theme(panel.background = element_rect(fill = NA)) + #背景透明色 # Transparent background color
  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system

gc1
后期处理
Post-processing
保存到pdf文件，是矢量图，可以用Illustrator等软件编辑图形、文字和背景
Save to a PDF file, which is a vector image. You can edit the graphics,
text, and background using software such as Illustrator.
ggsave("ccgraph.pdf",width = 14,height = 14)
多层嵌套
Multi-layer nesting
这套代码不仅可以画两层的图，理论上支持更多层（要不然怎么叫“圆环套圆环”呢？）。
This code can not only draw two layers of graphs, but theoretically
supports more layers (otherwise, how can we say “rings within
circles”?).
下面是一个例子，这里使用了常见的微生物组数据集（这是一个随机生成的
OTU 表）。 Below is an example using a common microbiome dataset (a
randomly generated OTU table).
#随机生成一套数据 # Generate a random data set
n <- 1000
microbiome <- data.frame(
  otu = paste("OTU",1:n,sep="_"),
  phylum = sample(paste("phylum",1:5,sep="_"),n,replace = T),
  class = sample(paste("class",6:30,sep="_"),n,replace=T),
  order = sample(paste("order",31:80,sep="_"),n,replace = T),
  value = runif(n,min=1,max=1000)
)
head(microbiome)

#保存到文件，便于小白套用格式 # Save to a file for easy formatting
write.csv(microbiome, "microbiome.csv", quote = F, row.names = F)
加载输入数据 Load input data
microbiome.csv，想画几层就给几+1列。这里前4列对应4层，最后一列是最底层节点对应的数值。
microbiome.csv. Add as many layers as you want + 1 column. Here, the
first four columns correspond to the four layers, and the last column is
the value corresponding to the bottom-level node.
microbiome <- read.csv("microbiome.csv", header = T)
index_micro <- c("phylum","class","order") #除了最低层以外的列名 #Column names except the lowest level
nodes_micro <- gather_graph_node(microbiome,index=index_micro,
                                  root = "bacteria") #root名字自己随便取 #The root name can be chosen by yourself
edges_micro <- gather_graph_edge(microbiome,index=index_micro,root = "bacteria")
画图 Draw a picture
graph_micro <- tbl_graph(nodes_micro,edges_micro)
ggraph(graph_micro,layout = "dendrogram",circular=T) +
  geom_edge_diagonal(aes(color = node1.node.branch,filter=node1.node.level!="bacteria", alpha = node1.node.level),edge_width=1) + 
  geom_node_point(aes(size = node.size, color = node.branch,filter=node.level!="bacteria"), alpha = 1/3) + 
  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that they are within the range
  theme(legend.position = "none")+ #不画图例 # Do not draw a legend
  
  scale_edge_color_brewer(palette = "Set1") + #用?scale_color_brewer查看更多配色方案 # Use ?scale_color_brewer to view more color schemes
  scale_color_brewer(palette = "Set1") +

  # 添加周围注释文字，此处是基因名gene
# Add surrounding annotation text, here is the gene name
  geom_node_text(
    aes(
      x = 1.058 * x, #控制字跟点的距离 # Distance between the control word and the point
      y = 1.058 * y, #控制字跟点的距离 # Distance between the control word and the point
      label = node.short_name,
      angle = -((-node_angle(x, y) + 90) %% 180) + 90,
      filter = leaf,
      color = node.branch
      ),
    size = 1, hjust = 'outward') +
  
  # 添加内环文字，此处是通路名term
# Add inner ring text, here is the pathway name
  geom_node_text(
    aes(label=node.short_name,
        filter = !leaf & (node.level == "phylum"),
        color = node.branch),
    fontface="bold",
    size=6,
    family="sans"
  ) + 
  theme(panel.background = element_rect(fill = NA)) +
  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system
ggsave("ccgraph_microbiome.pdf", width = 14, height = 14)
参考资料
References
https://mp.weixin.qq.com/s/JNIncz3W-59yjGk2ibJWUw
Session Information
sessionInfo()