FigureYa220repeatedLasso
FigureYa220repeatedLasso
Author(s)
: Xiaofan Lu
Date
: 2025-10-06
Academic Citation
If you use this code in your work or research, we kindly request that you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
Requirement Description
FigureYa182RFSurv和FigureYa198SignatureComb都是根据基因的重要性筛选的。直接根据随机森林的准确度或cox模型的frequency筛选，又是另一种不同的展示方式。
Both FigureYa182RFSurv and FigureYa198SignatureComb were screened based on the importance of genes. Filtering directly based on the accuracy of the random forest or the frequency of the COX model is another different way to display it.
出自
https://translational-medicine.biomedcentral.com/articles/10.1186/s12967-019-1824-4
From
https://translational-medicine.biomedcentral.com/articles/10.1186/s12967-019-1824-4
Fig. 2 a Generation of the ten gene groups after 1000 iteration. The gene model with 30 immune related genes was selected to construct the signature as its highest frequencies of 211 compared to other nine gene models. b The c‐index of both training and testing sets. The c‐index for TCGA dataset, GSE30219, GSE31210, GSE3141, and GSE81089 were 0.723, 0.657, 0.7061, 0.641, and 0.619 respectively
应用场景
Application Scenarios
这里用的cox模型的10折交叉验证
Here is a 10-fold cross-validation of the COX model
Using Cox proportional hazards model (iteration = 1000) with an lasso penalty to find the best gene model.
环境设置
Environment settings
source("install_dependencies.R")  # 加载依赖安装脚本 # Load dependency installation script
library(survival)  # 用于生存分析的包 # For survival analysis
library(glmnet)    # 用于Lasso和Elastic-Net正则化的包 # For Lasso and Elastic-Net regularization
library(pbapply)   # 用于显示进度条的包 # For displaying progress bars
library(survcomp)  # 用于生存数据比较的包 # For survival data comparison
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 # error messages are displayed in English
options(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor
自定义函数 Custom functions
display.progress = function (index, totalN, breakN=20) {
  
  if ( index %% ceiling(totalN/breakN)  ==0  ) {
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
}
输入文件
Input files
表达谱文件
InnateDB_genes.csv，免疫基因集。数据来自
https://www.innatedb.com/redirect.do?go=resourcesGeneLists
Immunogenetic Related Information Source (IRIS)
训练集
easy_input_expr.txt，表达谱
easy_input_surv.txt，生存数据
测试集，GEO数据的下载及数据预处理请参考FigureYa203ComBat，其余测试集如法炮制
easy_validation_expr.txt，表达谱
easy_validation_surv.txt，生存数据
The expression profile file
InnateDB_genes.csv, immune gene set. Data from
https://www.innatedb.com/redirect.do?go=resourcesGeneLists
Immunogenetic Related Information Source (IRIS)
Training sets
easy_input_expr.txt, expression profile
easy_input_surv.txt, survival data
For the test set, please refer to FigureYa203ComBat for downloading GEO data and data preprocessing, and the rest of the test sets are prepared in the same way
easy_validation_expr.txt, expression profile
easy_validation_surv.txt, survival data
用训练集筛基因
Sifting genes with training sets
单变量cox模型筛选基因，KM估计筛选基因，二者取交集。
The univariate cox model screened genes, and KM estimated the screened genes, and the two intersected.
# 单变量cox模型筛选基因
# Univariate Cox model for gene screening
Coxoutput <- NULL
for(i in 3:ncol(expr.surv)){
  display.progress(index = i,totalN = ncol(expr.surv),breakN = 20)
  g <- colnames(expr.surv)[i]
  cox <- coxph(Surv(OS.time,OS) ~ expr.surv[,i], data = expr.surv)
  coxSummary = summary(cox)
  Coxoutput=rbind(Coxoutput,data.frame(gene=g,
                                       HR=as.numeric(coxSummary$coefficients[,"exp(coef)"])[1],
                                       z=as.numeric(coxSummary$coefficients[,"z"])[1],
                                       pvalue=as.numeric(coxSummary$coefficients[,"Pr(>|z|)"])[1],
                                       lower=as.numeric(coxSummary$conf.int[,3][1]),
                                       upper=as.numeric(coxSummary$conf.int[,4][1]),stringsAsFactors = F))
}
cox.res <- Coxoutput[which(Coxoutput$pvalue < 0.05),"gene"] # 取出FDR<0.05的基因为候选基因 # The gene with FDR<0.05 was taken out as a candidate gene

# KM估计筛选基因
# KM estimation of screening genes
kmoutput <- NULL
for(i in 3:ncol(expr.surv)){
  display.progress(index = i,totalN = ncol(expr.surv),breakN = 20)
  g <- colnames(expr.surv)[i]
  tmp <- expr.surv[,c("OS.time","OS",g)]
  tmp$group <- ifelse(tmp[,3] > median(tmp[,3]),"High","Low")
  fitd=survdiff(Surv(OS.time, OS)~ group, data=tmp, na.action=na.exclude)
  p.val <- 1-pchisq(fitd$chisq, length(fitd$n)-1)
  
  kmoutput=rbind(kmoutput,data.frame(gene=g,
                                      pvalue=p.val,
                                      stringsAsFactors = F))
}
km.res <- kmoutput[which(kmoutput$pvalue < 0.05),"gene"]

# 取出交集基因
# Remove the intersecting genes
candidate.gene <- intersect(cox.res,km.res)

# 运行1000次multivariate cox model with lasso penalty
# Run the Multivariate Cox Model with Lasso Penalty 1000 times
iter.times <- 1000 # 设置迭代次数，速度非常慢请耐心，例文是1000次 # Set the number of iterations, the speed is very slow, please be patient, the example is 1000 times
surv.obj <- Surv(expr.surv$OS.time, expr.surv$OS)
lasso_fea_list <- list()

list.of.seed <- 1:iter.times
lasso_fea_list <- pblapply(list.of.seed, function(x){ # 大概运行2天 # It will run for about 2 days
  set.seed(list.of.seed[x])
  cvfit = cv.glmnet(x = as.matrix(expr.surv[,candidate.gene]), 
                    y = surv.obj, 
                    nfolds = 10, # 10-fold交叉验证选取最优lambda # 10-fold cross-validation to select the optimal lambda
                    alpha = 1, # alpha = 1 意味着 lasso # alpha = 1 means lasso
                    family = "cox", # 依赖cox模型 # Rely on the COX model
                    maxit = 1000) 
  
  # 取出最优lambda
  # Take out the optimal lambda
  fea <- rownames(coef(cvfit, s = 'lambda.min'))[coef(cvfit, s = 'lambda.min')[,1]!= 0]
  if(is.element("(Intercept)", fea)) {
    lasso_fea <- sort(fea[-1]) # 去掉截距项并排序 # Remove the intercept items and sort
  } else {
    lasso_fea <- sort(fea)
  }
  return(lasso_fea)
})
save(lasso_fea_list,file = "lasso_fea_list.rda") # 保存该结果 # Save the result

# 输出每次运行的基因集合
# Outputs the gene collection for each run
lasso_res <- NULL
for(i in 1:iter.times) {
  lasso_res <- rbind.data.frame(lasso_res,
                                data.frame(iteration = i,
                                           n.gene = length(lasso_fea_list[[i]]),
                                           genelist = paste0(lasso_fea_list[[i]], collapse = " | "),
                                           stringsAsFactors = F),
                                stringsAsFactors = F)
}

# 检查相同基因数目的集合成分是否一致
## 注意原文没有提到该做法，但的确存在相同基因数目的模型基因成分不完全一致的情况，已致邮给通讯作者未回复
## 这里可以看到32个基因的模型存在两种基因组分，虽不影响35基因被最终选中，但应考虑为不同模型
# Check whether the aggregate components of the same number of genes are consistent
## Note that this practice is not mentioned in the original text, but it does happen that the gene composition of the model with the same number of genes is not completely identical, and it has been mailed to the corresponding author without reply
## Here we can see that there are two genomes in the 32-gene model, which does not affect the final selection of 35 genes, but should be considered as different models
uniquelist <- unique(lasso_res$genelist)
uniquelab <- LETTERS[1:length(uniquelist)]
lasso_res$uniquelab <- NA
for (i in 1:length(uniquelist)) {
  lasso_res[which(lasso_res$genelist == uniquelist[i]),"uniquelab"] <- uniquelab[i]
}
lasso_res$label <- paste(lasso_res$n.gene,"genes",lasso_res$uniquelab,sep = "_") # 最终模型标签 # Final Model Label
训练集 - 计算risk score和C指数
Training Set - Calculate the risk score and C-index
sel.iter <- lasso_res[which(lasso_res$label == "35_genes_A"),"iteration"][1] # 选中模型为35_genes_A的某一次迭代种子（随便算哪个，基因集合都是一样的） # Select a certain iteration seed with the model as 35_genes_A (either is fine, the gene set is the same)
set.seed(sel.iter) # 设置当前种子以复现该基因集 # Set the current seed to replicate the gene set
cvfit = cv.glmnet(x = as.matrix(expr.surv[,candidate.gene]), 
                  y = surv.obj, 
                  nfolds = 10, # 10-fold交叉验证选取最优lambda # 10-fold cross-validation to select the optimal lambda
                  alpha = 1, # alpha = 1 意味着 lasso # alpha = 1 means lasso
                  family = "cox", # 依赖cox模型 # Rely on the COX model
                  maxit = 1000)
myCoefs <- coef(cvfit, s="lambda.min")
fea <- rownames(coef(cvfit, s = 'lambda.min'))[coef(cvfit, s = 'lambda.min')[,1]!= 0]
if(is.element("(Intercept)", fea)) {
  lasso_fea <- fea[-1] # 去掉截距项并排序 # Remove the intercept items and sort
  lasso_coef <- myCoefs@x; names(lasso_coef) <- lasso_fea
} else {
  lasso_fea <- fea
  lasso_coef <- myCoefs@x; names(lasso_coef) <- lasso_fea
}
tmp <- as.matrix(expr.surv[,lasso_fea])
risk.score <- apply(tmp,1,function(x) {x %*% as.numeric(lasso_coef)}) # 表达加权系数求和计算riskscore # Expression weighting coefficient summation calculates riskscore
cindex.tcga <- concordance.index(risk.score,
                                 surv.time = expr.surv$OS.time,
                                 surv.event = expr.surv$OS,
                                 method = "noether")
测试集 - 计算riskscore和C指数
Test Set - Calculate riskscore and C index
gse31210.expr$Gene <- sapply(strsplit(rownames(gse31210.expr)," /// ",fixed = T),"[",1)
gse31210.expr <- apply(gse31210.expr[,setdiff(colnames(gse31210.expr), "Gene")], 2, function(x) tapply(x, INDEX=factor(gse31210.expr$Gene), FUN=median, na.rm=TRUE))
gse31210.expr <- as.data.frame(round(gse31210.expr,2))

# 生存数据预处理
# Preprocessing of survival data
gse31210.surv <- read.delim("easy_validation_surv.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
gse31210.surv <- gse31210.surv[which(gse31210.surv$`1:DEATH` %in% c("alive","dead")),] # 剔除无结局样本 # Excluded samples with no outcome

comsam <- intersect(rownames(gse31210.surv),colnames(gse31210.expr)) # 取出共享样本 # Take out the shared sample
gse31210.expr <- gse31210.expr[,comsam]
gse31210.surv <- gse31210.surv[comsam,]

gse31210.expr.surv <- cbind.data.frame(data.frame("OS" = ifelse(gse31210.surv$`1:DEATH` == "dead", 1, 0),
                                                  "OS.time" = gse31210.surv$`1:DAYS BEFORE DEATH/CENSOR`,
                                                  stringsAsFactors = F),
                                       t(log2(as.matrix(gse31210.expr[lasso_fea,]) + 1))) # 表达谱对数化 # Logarithmicization of expression spectrum

## 计算riskscore和C指数
## Calculate riskscore and C index
tmp <- t(log2(as.matrix(gse31210.expr[lasso_fea,]) + 1))
risk.score.gse <- apply(tmp,1,function(x) {x %*% as.numeric(lasso_coef)}) # 表达加权系数求和计算riskscore # Expression weighting coefficient summation calculates riskscore
cindex.gse <- concordance.index(risk.score.gse,
                                surv.time = gse31210.expr.surv$OS.time,
                                surv.event = gse31210.expr.surv$OS,
                                method = "noether")
开始画图
Start drawing
par(mfrow = c(1,2)) # 创建画图并分割成左右两块 # Create a drawing and divide it into left and right pieces
## 图A
## Figure A
par(bty="o", mgp = c(1.9,.33,0), mar=c(5.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25)
plotdata <- sort(table(lasso_res$label))
a <- barplot(plotdata,
        ylab = "Frequency",
        col = "#00CDCD",
        main = "Frequency of models",
        border = NA,
        xaxt = "n",
        ylim = c(0,max(plotdata) + 70))
axis(side = 1, at = a, names(plotdata), las = 2) # 添加x轴标签 # Add x-axis labels
text(a, as.numeric(plotdata) + 30, as.numeric(plotdata), xpd = T) # 添加基因数目 # Add the number of genes
par(new = T, bty="o", mgp = c(1.9,.33,0), mar=c(5.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25) # 补全黑色边框 # Complete the black border
plot(NULL, NULL,
     col = "white",
     xlim = range(a), ylim = range(plotdata),
     xlab = "", ylab = "",
     xaxt = "n", yaxt = "n")

## 图B
## Figure B
par(bty="o", mgp = c(1.9,.33,0), mar=c(5.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25)
cindex <- c(cindex.gse$c.index, cindex.tcga$c.index)
b <- barplot(cindex,
        border = NA,
        ylim = c(0,1),
        col = "#00CDCD",
        main = "c-index",
        ylab = "c-index",
        xaxt = "n")
axis(side = 1, at = b, labels = c("GSE31210","TCGA"), las = 2) # 添加x轴标签 # Add x-axis labels
par(new = T, bty="o", mgp = c(1.9,.33,0), mar=c(5.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25) # 补全黑色边框 # Complete the black border
plot(NULL, NULL,
     col = "white",
     xlim = range(b), ylim = c(0,1),
     xlab = "", ylab = "",
     xaxt = "n", yaxt = "n")
dev.copy2pdf(file = "frequency and cindex of model.pdf", width = 8, height = 4.5) # 保存图片 # Save the image
Session Info
sessionInfo()