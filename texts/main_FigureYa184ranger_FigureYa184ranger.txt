FigureYa184ranger
FigureYa184ranger
Author(s)
: Xiaofan Lu
Reviewer(s)
: Ying Ge, Junyi Shen
Date
: 2025-09-22
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
Requirement
实现随机森林滑动窗口法。 Implement the random forest sliding window
method.
出自
https://www.tandfonline.com/doi/full/10.1080/15592294.2019.1573066
fromhttps://www.tandfonline.com/doi/full/10.1080/15592294.2019.1573066
Figure 2. Ranger provides variable importance score (VIS) for each
CpG probe for lung adenocarcinoma (LUAD) patients only in the discovery
phase and the validation phase. “Out of bag (OOB)” error rate of top CpG
probes in the model, when probes were included one by one based on their
VIS ranks in the discovery (A) and the validation phase (B).
应用场景
Application Scenarios
使用加权随机森林对生存数据降维，根据sliding windows sequential
forward feature selection法筛选变量 The weighted random forest was used
to reduce the dimension of the survival data, and the variables were
screened according to the sliding windows sequential forward feature
selection method
环境设置
Environment Setup
source("install_dependencies.R")
library(ranger)
library(randomForest)
library(survival)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息  # Display an English error message
options(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor
自定义函数 Custom function
# 显示进程
# Show Process
display.progress = function (index, totalN, breakN=20) {
  if ( index %% ceiling(totalN/breakN)  ==0  ) {
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
}
输入文件
Input File
easy_input_expr.csv，表达矩阵。 easy_input_expr.csv, expressing
matrix.
easy_input_cli.csv，临床信息。这两个文件跟FigureYa128Prognostic、FigureYa182RFSurv的一样，可以对比感受一下筛选效果。
easy_input_cli.csv, clinical information. These two documents are the
same as those of FigureYa128Prognostic and FigureYa182RFSurv. You can
compare them to get a sense of the screening effect.
exp <- read.csv("easy_input_expr.csv",header = T,row.names = 1,check.names = F,stringsAsFactors = F)
cli <- read.csv("easy_input_cli.csv",header = T,row.names = 1,check.names = F,stringsAsFactors = F)

# 提取既有表达数据又有临床数据的样本
# Extract samples that have both expressive data and clinical data
com_sam <- intersect(colnames(exp),rownames(cli))
exp <- exp[,com_sam]
cli <- cli[com_sam,]

# 去除无表达的基因
# Remove unexpressed genes
exp <- exp[rowSums(exp) > 0,]

# 去除超过10%的样本表达量为0的基因
# Remove genes with expression levels of 0 from more than 10% of the samples
exp <- exp[rowSums(exp == 0) < 0.1 * ncol(exp),]

# 对数转化
# Logarithmic Transformation
exp <- log(exp + 1)
单变量cox模型筛选预后基因
Univariate cox model for screening prognostic genes
理论上表达谱会优先进行一些筛选避免增加运算时间，如使用单变量cox模型筛选预后基因(P
< 0.01) Theoretically, the expression profile would prioritize some
screenings to avoid increasing the operation time, such as using a
univariate cox model to screen prognostic genes (P < 0.01).
# 过滤出与OS有关的基因
# Filter out genes related to OS
cox.pcutoff <- 0.001
Coxoutput.OS <- NULL
for (i in 1:nrow(exp)) {
  display.progress(index = i,totalN = nrow(exp)) # 显示进度   # shows progress


  
  # 产生临时变量存储生存以及变量表达值
  # Generate temporary variables to store survival and variable expression values
  tmp <- data.frame(gene = as.numeric(exp[i,]),
                    OS.time = cli[,"OS.time"],
                    OS = cli[,"OS"],
                    stringsAsFactors = F)
  
  # 单变量cox比例风险模型
  # Univariate cox proportional hazards model
  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)
  coxSummary = summary(cox)
  
  # 生成cox结果数据框，包括基因名，风险比，z值，waldtest p值，以及HR置信区间
  # Generate cox result data frames, including gene names, hazard ratios, Z-values, waldtest P-values, and HR confidence intervals
  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(exp)[i],
                                                        HR=as.numeric(coxSummary$coefficients[,"exp(coef)"]),
                                                        z=as.numeric(coxSummary$coefficients[,"z"]),
                                                        pvalue=as.numeric(coxSummary$coefficients[,"Pr(>|z|)"]),
                                                        lower=as.numeric(coxSummary$conf.int[,3]),
                                                        upper=as.numeric(coxSummary$conf.int[,4]),
                                                        stringsAsFactors = F),
                                stringsAsFactors = F)
}
write.csv(Coxoutput.OS,"univariate cox regression for gene filtering.csv",row.names = F,quote = F)
前面跟FigureYa182RFSurv的相同，下面就不一样了。 The front part is the
same as that of Figure A182 RFSURV, but the bottom part is
different.
加权随机森林进一步降维
Weighted random forests further reduce dimensions
gene.sel <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),"gene"]
tmp <- exp[gene.sel,]
rownames(tmp) <- gsub("-","_",rownames(tmp)) # 防止出现“-”导致程序报错  # Prevent the occurrence of "-" from causing program errors
dt.rf <- cbind.data.frame(cli,t(tmp))
dt.rf <- dt.rf[,setdiff(colnames(dt.rf),"OS.time")] # 二分类分类树，结局考虑overall survival  # binary classification tree, with overall survival as the outcome

ntree <- 500
mtry <- floor(sqrt(length(gene.sel)))
weight <- 0.999999 # 算法要求无法取1但无限接近1，该参数表示变量被选择的概率，原文为100%。 #The algorithm requires that it cannot take 1 but is infinitely close to 1. This parameter represents the probability of the variable being selected, which is 100% in the original text.
seed <- 001

set.seed(seed) # 设置外部种子保证结果可重复 # Sets an external seed to ensure repeatability of the result
surv.rf <- ranger(formula = OS ~ ., 
                  data = dt.rf,
                  num.trees = ntree,
                  mtry = mtry,
                  importance = "impurity",
                  split.select.weights = rep(weight,length(gene.sel)))
# 变量重要性按照降序排列
# Variable importance is arranged in descending order
var.imp <- sort(ranger::importance(surv.rf),decreasing = T)
逐步回归筛选变量
Stepwise regression screens for variables
例文采用sliding windows sequential forward feature selection The
example text adopts sliding windows sequential forward feature
selection
简单思路为，根据重要性逐步纳入基因，每一次做当前基因组合下的随机森林并计算oob，取oob达到最小时的组合。
The simple idea is to gradually incorporate genes based on their
importance. Each time, create a random forest under the current gene
combination and calculate the oob. Take the combination with the
smallest oob.
ntree <- 500 # 树的数目，一般为500 #The number of trees is generally 500
nPerm <- 50 # 扰动次数，一般为50 # The number of disturbances is generally 50
var.now <- oob <- c()
for (var in names(var.imp)) {
  cat(var,"\n")
  set.seed(seed)
  var.now <- c(var.now,var)
  swsfs.dt <- dt.rf[,c("OS",var.now)]
  swsfs.dt$OS <- factor(swsfs.dt$OS)
  model_RF <- randomForest(OS ~ ., 
                           data = swsfs.dt,
                           ntree = ntree, 
                           nPerm = nPerm, 
                           mtry = floor(sqrt(ncol(swsfs.dt))), 
                           proximity = T,
                           importance = F)
  oob <- c(oob,model_RF$err.rate[ntree,1])
}
names(oob) <- names(var.imp)
signature <- var.imp[1:which.min(oob)] # 取oob达到最小时候的gene组合作为最终signature  # Take the gene combination when oob reaches its minimum as the final signature
write.table(data.frame(signature = names(signature),importance = as.numeric(signature),stringsAsFactors = F),
            "signature with importance.txt",sep = "\t",row.names = F,quote = F)
开始画图
Start drawing
#pdf("oob from swsfs.pdf",width = 6,height = 5.5)
par(bty = "o", mgp = c(1.5,.33,0), mar = c(3,4,1,2),las = 1, tcl = -.25)
plot(1:length(gene.sel),oob,
     xlab = "Number of Genes",
     ylab = "",
     type = "l",
     lty = 4,
     col = "red", # 可修改线的颜色 # The color of the line can be modified
     cex = 1.5)
mtext("OOB error rate",side = 2,line = 2.5,las = 3) # 添加y标签 # Add the y tag
points(1:length(gene.sel),oob,# 加圆圈 # with circles
       col = "red", # 可修改圆圈颜色   # can modify the color of the circle
       pch = 19)
abline(v = which.min(oob),lty = 2, col = "red") # 找到oob最小的位置添加垂直虚线  # Find the position where oob is the smallest and add a vertical dotted line
#invisible(dev.off())

# save.image("ranger.RData")
Session Info
sessionInfo()