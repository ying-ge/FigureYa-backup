FigureYa243scMarkerGroupHeatmap
FigureYa243scMarkerGroupHeatmap
2025-5-20
需求描述
只要这张图中间的热图部分。scRNA分不同的cluster鉴定细胞类型；两组之间比较markers的表达高低，调整顺序绘制热图。
Requirement Description
I only need the heatmap portion in the center of this image. scRNA is divided into different clusters to identify cell types; marker expression levels are compared between the two groups, and the order is adjusted to create the heatmap.
出自
https://www.ahajournals.org/doi/10.1161/CIRCULATIONAHA.119.043833
Figure 1. Neutrophils dominate the heart after myocardial infarction (MI).
D, Gene ontologies of cell-specific differentially expressed genes. The heat maps depict genes ranked by the degree of cell-type specific enrichment. The P value of Gene Ontology enrichment in each gene set is reported. n=4 per sample.
应用场景
例文该图用的是bulk RNA-seq数据，小伙伴觉得特适合用来展示单细胞marker基因在多个cluster当中的表达模式。
环境设置
使用国内镜像安装包
Application Scenarios
This example figure uses bulk RNA-seq data, which I find particularly suitable for demonstrating the expression patterns of single-cell marker genes across multiple clusters.
Environment Settings
Using a domestic mirror installation package
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")
install.packages("Seurat")
devtools::install_github("satijalab/seurat-data")
install.packages("colorRamps")
加载包
Load package
library(Seurat)
library(SeuratData)
library(patchwork)
library(RColorBrewer)
library(colorRamps)
library(pheatmap)
library(dplyr)
library(magrittr)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 #Display English error messages
options(stringsAsFactors = FALSE) #禁止chr转成factor
输入文件及前期处理
这里用Seurat的数据，便于小伙伴套用在自己的单细胞数据上。
Input Files and Preliminary Processing
Seurat data is used here to facilitate application to your own single-cell data.
# install dataset
InstallData("ifnb")
# load dataset
LoadData("ifnb")
# ifnb数据集中包含两个样本数据，分别为CTRL和STIM # The ifnb dataset contains two sample data, CTRL and STIM
head(ifnb@meta.data)
table(ifnb@meta.data$stim)
# 使用splitobject将ifnb数据集分割成两个seurat对象的列表(STIM和CTRL) # Use splitobject to split the ifnb dataset into two lists of seurat objects (STIM and CTRL)
ifnb.list <- SplitObject(ifnb, split.by = "stim")

# 对两个数据集单独进行normalize并识别各自的高变异基因 # Normalize both datasets and identify highly variable genes in each.
ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})


# 计算两个数据中排完rank后top2000的高变异基因 # Calculate the top 2000 highly variable genes in both datasets after ranking.
features <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 2000)
 
# 使用上述高变异基因在两个基因集中分别执行PCA # Perform PCA on both gene sets using the highly variable genes.
ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- ScaleData(x, features = features, verbose = T)
  x <- RunPCA(x, features = features, verbose = T)
})
# 对两个数据集进行整合 # Integrate the two datasets
# 首先使用findinintegrationanchors函数标识锚点，然后使用IntegrateData函数将两数据集整合在一起
# 可以通过调整k.anchor参数调整两个样本整合的强度，默认为5，数字越大整合强度越强
# First, use the findintegrationanchors function to identify anchor points, then use the integrateData function to integrate the two datasets.
# You can adjust the k.anchor parameter to adjust the strength of the integration between the two samples. The default value is 5; a larger number increases the integration strength.
immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features, reduction = "rpca", k.anchor = 20)
immune.combined <- IntegrateData(anchorset = immune.anchors)
# 对整合后的数据进行后续分析 # Perform subsequent analysis on the integrated data
DefaultAssay(immune.combined) <- "integrated"
常规单细胞流程General Single-Cell Process
# 常规流程，scale数据，跑PCA，使用前30个PC进行降维跑UMAP，计算Neighbors，分cluster # Perform the general process: scale the data, run PCA, use the first 30 PCs for dimensionality reduction, run UMAP, calculate neighbors, and cluster.
immune.combined <- ScaleData(immune.combined, verbose = FALSE)
immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)
immune.combined <- RunUMAP(immune.combined, reduction = "pca", dims = 1:30)
immune.combined <- FindNeighbors(immune.combined, reduction = "pca", dims = 1:30)
immune.combined <- FindClusters(immune.combined, resolution = 0.5)
计算marker基因