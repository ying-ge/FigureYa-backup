FigureYa274MuSiCbulkProop
FigureYa274MuSiCbulkProop
Author(s)
: Xiao Gu; Yasi Zhang
Reviewer(s)
: Ying Ge
Date
: 2025-09-12
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
需求描述
Demand description
用MuSic反卷积推算bulk组的细胞类型。
出自
https://www.nature.com/articles/s41467-018-08023-x
Using MuSic deconvolution to infer cell types in bulk groups.
Source:
https://www.nature.com/articles/s41467-018-08023-x
应用场景
Application scenarios
MuSic这个软件大概有三个功能：
第一个就是直接根据单细胞数据和bulk数据预测bulk中大概含有单细胞鉴定到的哪几种细胞类型
第二个是先聚类，然后根据聚类信息和输入的marker
list做，感觉主观性强
第三个是两个单细胞数据集进行相互验证，参考意义不大
流程跟着教程跑就好，官方详细教程见：
https://xuranw.github.io/MuSiC/articles/MuSiC.html#sample-analysis-1
跟FigureYa71ssGSEA的相似之处：核心理念都是用单细胞的数据算出来每种细胞类型的marker
gene，然后看这些基因中的哪些在bulk中高表达。
同样用到单细胞和bulk的FigureYa272scBulkCCCI，借助scRNA-seq找到的signature
genes，推断bulk RNA-seq样本的细胞类群互作网络。
The MuSiC software has approximately three main functions:
The first is to directly predict which cell types identified from
single-cell data are likely present in bulk data, based on both
single-cell and bulk datasets.
The second involves clustering first and then using the clustering
information along with an input marker list, which tends to be more
subjective.
The third is mutual validation between two single-cell datasets,
though its reference value is relatively limited.
The workflow can be followed according to the tutorial. For the
official detailed tutorial, see:
https://xuranw.github.io/MuSiC/articles/MuSiC.html#sample-analysis-1
Similarities with FigureYa71ssGSEA: The core concept of both is to
use single-cell data to calculate marker genes for each cell type and
then identify which of these genes are highly expressed in bulk
data.
Another tool that also utilizes both single-cell and bulk data is
FigureYa272scBulkCCCI. It leverages signature genes identified from
scRNA-seq to infer cell-cell interaction networks in bulk RNA-seq
samples.
比较难的就是构建数据集，本文档带大家解决这个问题。
The most challenging part is constructing the dataset, and this
document will guide you through solving this issue.
分两种情况，分别带大家跑通：
第一种方案：
不预分组
预测bulk数据中细胞类型占比
第二种方案：
基于细胞类型预分组
预测bulk数据中细胞类型占比
We will cover two scenarios to help you successfully complete the
analysis:
Option 1: Predicting cell type proportions in bulk data
without pre-grouping
.
Option 2: Predicting cell type proportions in bulk data
based on pre-grouped cell types
.
环境设置
Environment Setup
source("install_dependencies.R")
library(Seurat)
library(SeuratData)
library(patchwork)
library(dplyr)
library(MuSiC)
library(pheatmap)
library(magrittr)
library(Biobase)
library(glmGamPoi)
library(SingleCellExperiment)
# 显示英文报错信息
# Show English error messages
Sys.setenv(LANGUAGE = "en") 

# 禁止chr转成factor
# Prevent character-to-factor conversion
options(stringsAsFactors = FALSE)
第一种方案: 不预分组预测bulk数据中细胞类型占比
Option 1: Predicting Cell Type Proportions in Bulk Data Without
Pre-Grouping
输入文件
Input Files
构建单细胞数据集
Constructing the Single-Cell Dataset
ifnb
- A Seurat object with the PBMC
control/IFNB-stimulated dataset。出自
https://pubmed.ncbi.nlm.nih.gov/29227470/
，已被打包到SeuratData里，我们直接安装、加载它。
为了友好对接目前主流的Seurat单细胞分析流程，使用SeuratData包钟的ifnb数据集做示例数据，示例数据ifnb有STIM和CTRL两组。
ifnb
– A Seurat object containing the PBMC
control/IFNB-stimulated dataset, sourced from
https://pubmed.ncbi.nlm.nih.gov/29227470/
. This dataset
has been pre-packaged in SeuratData, so we can directly install and load
it.
To ensure compatibility with the current mainstream Seurat
single-cell analysis pipeline, we use the ifnb dataset from the
SeuratData package as an example. The example dataset ifnb contains two
groups: STIM (stimulated) and CTRL (control).
# 找网络好点的地方安装，教育网好些
# Recommended to install in a stable network environment (educational networks work better)
# InstallData("ifnb") 
LoadData("ifnb")
# 更新Seurat对象结构至最新版本
# Update Seurat object to latest structure
ifnb <- UpdateSeuratObject(ifnb)
# 以下为Seurat标准分析流程，拿到使用SCTransform normalized的表达矩阵
# Standard Seurat analysis pipeline below to obtain SCTransform-normalized expression matrix
ifnb.list <- SplitObject(ifnb, split.by = "stim")

# 对每组数据独立进行质控和标准化
# Perform QC and normalization independently per group
ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- PercentageFeatureSet(x, pattern = "^MT-", col.name = "percent.mt")
  x <- SCTransform(x, method = "glmGamPoi", vars.to.regress = "percent.mt", verbose = FALSE)
})
# 选择用于整合的高变基因
# Select highly variable features for integration
features <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 3000)

# 准备SCT校正后的数据
# Prepare SCT-corrected data for anchor identification
ifnb.list <- PrepSCTIntegration(object.list = ifnb.list, anchor.features = features)

# 识别整合锚点
# Find integration anchors
immune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, normalization.method = "SCT",
                                         anchor.features = features)
# 执行数据整合
# Perform dataset integration
immune.combined.sct <- IntegrateData(anchorset = immune.anchors, normalization.method = "SCT")
# 以下是Seurat工作流中标准的可视化和聚类分析步骤
# These are now standard steps in the Seurat workflow for visualization and clustering
immune.combined.sct <- RunPCA(immune.combined.sct, npcs = 50, verbose = FALSE)

# 生成PCA热图（评估PCs质量）
# Generate PCA heatmap (evaluate PC quality)
pdf("DimHeatmap.pdf",height = 20,width = 20)
DimHeatmap(immune.combined.sct, dims = 1:50, cells = 500, balanced = TRUE,ncol = 6)
dev.off()
# 生成肘部图（确定显著PCs数量）
# Generate elbow plot (determine significant PCs)
pdf("ElbowPlot.pdf",height = 5,width = 10)
ElbowPlot(immune.combined.sct, ndims = 50)
dev.off()
由于SCTransform
normalized的效果很好，所以使用更多的PC能揭示更多的生物学信息，这里选择30个PC。
Since SCTransform normalization yields excellent results, using more
principal components (PCs) can reveal richer biological insights. Here,
we select 30 PCs for downstream analysis.
# 运行UMAP非线性降维
# Perform UMAP nonlinear dimensionality reduction
immune.combined.sct <- RunUMAP(immune.combined.sct, dims = 1:30, verbose = FALSE)
# 构建KNN
# Build KNN
immune.combined.sct <- FindNeighbors(immune.combined.sct, dims = 1:30, verbose = FALSE)

# 使用Louvain算法进行细胞聚类
# Perform cell clustering with Louvain algorithm
immune.combined.sct <- FindClusters(immune.combined.sct, resolution = 1.2, verbose = FALSE)

# 绘制基于聚类的UMAP图
# Plot UMAP colored by cluster
pdf("DimPlot.cluster.pdf",height = 5,width = 5)
DimPlot(immune.combined.sct, label = TRUE) + NoLegend()
dev.off()
# 绘制基于注释的UMAP图
# Plot UMAP colored by annotations 
pdf("DimPlot.celltype.pdf",height = 5,width = 5)
DimPlot(immune.combined.sct, group.by = "seurat_annotations", label = TRUE) + NoLegend()
dev.off()
# 从Seurat对象中提取标准化后的表达矩阵
# Extract normalized expression matrix from Seurat object
gene_exprs.matrix <- as.matrix(immune.combined.sct@assays$SCT@data)
# 创建元数据描述信息
# Create metadata descriptions
metadata <- data.frame(labelDescription= c("seurat_annotations","stim","seurat_clusters"),                      row.names=c("seurat_annotations","stim","seurat_clusters"))

# 提取关键表型信息（细胞类型+分组+聚类ID）
# Extract key phenotypic information (celltype + group + cluster)
pheno.matrix <- immune.combined.sct@meta.data[,c("seurat_annotations","stim","seurat_clusters")]

# 构建ExpressionSet对象
# Create ExpressionSet object
scRNA.eset <- ExpressionSet(assayData = data.matrix(gene_exprs.matrix), 
                           phenoData =  new("AnnotatedDataFrame", data = pheno.matrix, 
                                            varMetadata = metadata))

# 检查细胞类型分布
# Check cell type distribution
table(scRNA.eset$seurat_annotations)
构建bulk的ExpressionSet对象
Constructing Bulk ExpressionSet Object
这里随机生成一个bulk数据。
对于自己的数据，需要输入normalized之后的表达矩阵，然后构建bulk的ExpressionSet对象。
Here we randomly generate a bulk dataset as an example.
For your own data, you need to input a normalized expression matrix
and then construct the bulk ExpressionSet object accordingly.
# 设置模拟样本数和基因数
# Set number of simulated samples and genes
nsample <- 10
ngene <- nrow(gene_exprs.matrix)

# 设置随机数重点，好重复
# Set random seed for reproducibility  
set.seed(1) 

# bulk.mattrix一定要是矩阵格式
# bulk.matrix must be in matrix format 
bulk.mattrix <- matrix(runif(ngene*nsample, min = 0, max = 1000), 
                       nrow=ngene, ncol=10)

# 添加行列名称
# Add dimension names
rownames(bulk.mattrix) <- rownames(gene_exprs.matrix)
colnames(bulk.mattrix) <- paste0("sample", 1:nsample)

# 创建元数据描述框架
# Create metadata description framework
bulk.metadata <- data.frame(labelDescription= c("sample"), 
                            row.names=c("sample"))
bulk.metadata
# 构建样本表型数据
# Build sample phenotype data
bulk.pheno.matrix <- data.frame(sample= colnames(bulk.mattrix), 
                                row.names=colnames(bulk.mattrix))

# bulk数据集构建
# Bulk dataset construction
bulk.eset <- ExpressionSet(assayData = data.matrix(bulk.mattrix), 
                           phenoData = new("AnnotatedDataFrame", data = bulk.pheno.matrix, 
                                           varMetadata = bulk.metadata))
估计细胞类型比例
Estimate cell type proportions
# 将ExpressionSet转换为SingleCellExperiment对象
# Convert ExpressionSet to SingleCellExperiment
scRNA.sce <- SingleCellExperiment(
  assays = list(counts = exprs(scRNA.eset)),
  colData = pData(scRNA.eset)
)

# 执行MuSiC细胞比例估计
# Perform MuSiC cell proportion estimation
Est.prop <- music_prop(
  bulk.mtx = exprs(bulk.eset),
  sc.sce = scRNA.sce,
  clusters = 'seurat_annotations',
  samples = 'stim',
  select.ct = c("CD14 Mono", "pDC", "CD4 Memory T", "T activated", "CD4 Naive T",
                "CD8 T", "Mk", "B Activated", "B", "DC", "CD16 Mono", "NK", "Eryth")
)
# 查看估计结果的结构
# Examine result structure
names(Est.prop)
图3e - MuSiC估计的细胞类型比例
Figure 3e - MuSiC estimated cell type proportions
# 创建对称的颜色断点（用于双向颜色标尺）
# Create symmetric color breaks (for bidirectional color scale)
bk <- c(seq(-2,-0.1,by=0.01),seq(0,2,by=0.01))

# 热图绘制
# Generate Heatmap
pheatmap(Est.prop$Est.prop.weighted,
         cluster_cols = F,cluster_rows = F,
         show_colnames=T,show_rownames=T,
         #cellheight= 10,
         fontsize=16,
         #cellwidth = 10,cellheight = 10,
         treeheight_row = 0,treeheight_col_row = 10,
         #treeheight_col = 50,
         color = c(colorRampPalette(colors = c("steelblue","white"))(length(bk)/2),
                   colorRampPalette(colors = c("white","red"))(length(bk)/2)),
         border=F,border_color = "white",
         breaks=bk,scale="row",legend_breaks=seq(-2,2,1),
         filename = "Est.celltype.proportions.heatmap.pdf")
热图可以清楚看到随机生成的bulk数据大部分细胞为中含有单细胞鉴定的细胞类型中的pDC。
The heatmap clearly shows that in the randomly generated bulk data,
most samples contain pDC (plasmacytoid dendritic cells) - one of the
cell types identified in the single-cell analysis.
图2c - 抖动图
Figure 2c - Jitter plot
# 估计细胞类型比例的抖动图
# Jitter plot of estimated cell type proportions
jitter.fig <- Jitter_Est(list(data.matrix(Est.prop$Est.prop.weighted),
                             data.matrix(Est.prop$Est.prop.allgene)),
                        method.name = c('MuSiC', 'NNLS'), title = 'Jitter plot of Est Proportions')

# 保存为PDF
# Save as PDF
ggsave("Est.celltype.proportions.jitterplot.pdf",plot=jitter.fig,width =10,height = 8)
第二种方案：基于细胞类型预分组预测bulk数据中细胞类型占比
Option 2: Predicting cell type proportions in bulk data based on
pre-grouped cell types
输入文件
Input Files
这里用原文提供的数据集，已提前预分组，有自定义marker
list。下载地址：
Single cell data:
https://xuranw.github.io/MuSiC/data/Mousesubeset.rds
Bulk RNA-seq data:
https://xuranw.github.io/MuSiC/data/Mousebulkeset.rds
Marker gene list:
https://xuranw.github.io/MuSiC/data/IEmarkers.RData
自己的数据构建方式参考上面第一种方案。
The original dataset provided in the paper is used here, which has
been pre-grouped with a custom marker list. Download links:
Single-cell data:
https://xuranw.github.io/MuSiC/data/Mousesubeset.rds
Bulk RNA-seq data:
https://xuranw.github.io/MuSiC/data/Mousebulkeset.rds
Marker gene list:
https://xuranw.github.io/MuSiC/data/IEmarkers.RData
For constructing your own dataset, please refer to the first option
above.
# 加载小鼠Bulk数据集
# Load Mouse bulk dataset
Mouse.bulk.eset <- readRDS("Mousebulkeset.rds")
Mouse.bulk.eset
# 加载EMTAB单细胞数据集
# Load EMTAB single cell dataset
Mousesub.eset <- readRDS("Mousesubeset.rds")
Mousesub.eset
# 查看单细胞数据中的细胞类型级别
# Check cell type levels in scRNA data
levels(Mousesub.eset$cellType)
生成第一步分析信息。
注意，单细胞数据集包含16种细胞类型，其中包括2种新型细胞类型和1种过渡细胞类型(CD-Trans)。在我们的分析中排除了这3种细胞类型。
这里在分析中排除三种细胞类型，用剩余的细胞类型进行下游分析。
Produce the first step information.
Notice that the single cell dataset has 16 cell types, including 2
novel cell types and a transition cell type (CD-Trans). We exclude those
3 cell types in our analysis.
Here we exclude these 3 cell types from the analysis and use the
remaining cell types for downstream analysis.
# 创建SingleCellExperiment对象
# Create SingleCellExperiment object
Mousesub.sce <- SingleCellExperiment(
  assays = list(counts = exprs(Mousesub.eset)), 
  colData = pData(Mousesub.eset)               
)

# 现在运行music_basis函数
# Now run music_basis function
Mousesub.basis <- music_basis(
  Mousesub.sce, 
  clusters = 'cellType', 
  samples = 'sampleID',
  select.ct = c('Endo', 'Podo', 'PT', 'LOH', 'DCT', 'CD-PC', 'CD-IC', 'Fib',
                'Macro', 'Neutro', 'B lymph', 'T lymph', 'NK')
)
图3a - 聚类树状图
Figure 3a - Cluster dendrogram
绘制设计矩阵的树状图及各样本间相对丰度的均值
Plot the dendrogram of design matrix and cross-subject mean of
realtive abundance
# 创建PDF输出文件
# Create PDF output file
pdf("Est.celltype.cluster.pdf",width =10,height = 5)

# 设置1行2列的绘图布局
# Set 1-row x 2-column plot layout
par(mfrow = c(1, 2))

# 计算设计矩阵的欧式距离
# Calculate Euclidean distance of design matrix
d <- dist(t(log(Mousesub.basis$Disgn.mtx + 1e-6)), method = "euclidean")

# 使用完全连接法进行层次聚类
# Hierarchical clustering using Complete Linkage
hc1 <- hclust(d, method = "complete" )

# 绘制获得的树状图
# Plot the obtained dendrogram
plot(hc1, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix)')

# 计算相对丰度均值的欧式距离
# Calculate Euclidean distance of mean relative abundance
d <- dist(t(log(Mousesub.basis$M.theta + 1e-8)), method = "euclidean")

# 使用完全连接法进行层次聚类
# Hierarchical clustering using Complete Linkage
hc2 <- hclust(d, method = "complete")

# 绘制获得的树状图 
# Plot the obtained dendrogram
plot(hc2, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA)')
dev.off()
免疫细胞聚集在一起，而肾脏特异性细胞也各自聚为一类。值得注意的是，DCT（远曲小管细胞）和PT（近端小管细胞）属于同一个高级别分组。分组阈值可由用户自行确定。这里我们将13种细胞类型划分为4个组别：
Group 1: 中性粒细胞
Group 2: 足细胞
Group 3:
内皮细胞、集合管主细胞、集合管闰细胞、髓袢升支粗段、远曲小管细胞、近端小管细胞
Group 4:
成纤维细胞、巨噬细胞、自然杀伤细胞、B淋巴细胞、T淋巴细胞
小鼠肾脏分析的树状图引导递归估计包含两个步骤：
Step 1：估计各高级别细胞群的占比(p1,p2,p3,p4)
Step
2：估计各细胞群内部的具体细胞类型占比(p31,p32,…,p36,p41,…,p45)
The immune cells are clustered together and the kidney specific cells
are clustered together. Notice that DCT and PT are within the same
high-level grouping. The cut-off is user determined. Here we cut 13 cell
types into 4 groups:
Group 1: Neutro
Group 2: Podo
Group 3: Endo, CD-PC, CD-IC, LOH, DCT, PT
Group 4: Fib, Macro, NK, B lymph, T lymph
The tree-guided recursive estimation for mouse kidney analysis
includes 2 steps:
Step 1. Estimate proportions of each high level cluster;
(p1,p2,p3,p4)
Step 2. Estimate cell type proportions within each cluster;
(p31,p32,…,p36,p41,…,p45)
# 根据层次聚类结果手动定义细胞类型分组（需根据实际聚类树调整）
# Manually define cell type groups based on clustering results (adjust according to dendrogram)
clusters.type = list(C1 = 'Neutro', C2 = 'Podo', C3 = c('Endo', 'CD-PC', 'LOH', 'CD-IC', 'DCT', 'PT'), C4 = c('Macro', 'Fib', 'B lymph', 'NK', 'T lymph'))

# 初始化分组标签向量
# Initialize cluster labels
cl.type = as.character(Mousesub.eset$cellType)

# 将原始细胞类型映射到聚类分组
# Map original cell types to cluster groups
for(cl in 1:length(clusters.type)){
  cl.type[cl.type %in% clusters.type[[cl]]] = names(clusters.type)[cl]
}

# 添加分组信息到单细胞数据
# Add cluster info to scRNA data
pData(Mousesub.eset)$clusterType = factor(cl.type, levels = c(names(clusters.type), 'CD-Trans', 'Novel1', 'Novel2'))

# 提取用于后续分析的13种主要细胞类型
# Extract 13 major cell types for downstream analysis
s.mouse = unlist(clusters.type)
s.mouse
# 加载预定义的标记基因集（需提前准备）
# Load predefined marker gene sets (prepare in advance)
(load("IEmarkers.RData"))
# This RData file provides two vectors of gene names Epith.marker and Immune.marker

# 构建分组标记基因列表（与聚类分组对应）
# Build cluster-specific marker list (must match cluster names)
IEmarkers = list(NULL, NULL, 
                 Epith.marker, Immune.marker) # marker gene
names(IEmarkers) = c('C1', 'C2', 'C3', 'C4')
# The name of group markers should be the same as the cluster names
估算细胞类型比例
Estimate cell type proportions
# 将分组信息从ExpressionSet传递到SingleCellExperiment对象
# Transfer cluster annotations from ExpressionSet to SingleCellExperiment
Mousesub.sce$clusterType <- pData(Mousesub.eset)$clusterType

# 执行基于组群的MuSiC反卷积
# Perform group-aware MuSiC deconvolution
Est.mouse.bulk <- music_prop.cluster(
  bulk.mtx = exprs(Mouse.bulk.eset),
  sc.sce = Mousesub.sce,
  group.markers = IEmarkers,
  clusters = 'cellType',      
  groups = 'clusterType',     
  samples = 'sampleID',
  clusters.type = clusters.type
)
图3e - MuSiC估算的细胞类型比例
Figure 3e - MuSiC estimated cell type proportions
# 提取加权后的细胞群比例估计结果
# Extract weighted cell group proportion estimates
plot.df2 <- Est.mouse.bulk$Est.prop.weighted.cluster

library(pheatmap)

# 创建对称颜色断点（用于双向标度）
# Create symmetric color breaks (for bidirectional scale)
bk <- c(seq(-2,-0.1,by=0.01),seq(0,2,by=0.01))

# 热图绘制
# Generate Heatmap
pheatmap(plot.df2,
         cluster_cols = F,cluster_rows = F,
         show_colnames=T,show_rownames=T,
         #cellheight= 10,
         fontsize=16,
         #cellwidth = 10,cellheight = 10,
         treeheight_row = 0,treeheight_col_row = 10,
         #treeheight_col = 50,
         color = c(colorRampPalette(colors = c("steelblue","white"))(length(bk)/2),
                   colorRampPalette(colors = c("white","red"))(length(bk)/2)),
         border=F,border_color = "white",
         breaks=bk,scale="row",legend_breaks=seq(-2,2,1),
         filename = "Est.cluster.celltype.proportions.heatmap.pdf")
预测结果：该bulk数据中PT占据比例最大
Prediction results: PT (Proximal Tubule) cells account for the
highest proportion in this bulk data.
Session Info
sessionInfo()