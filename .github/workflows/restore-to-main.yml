name: Restore to Main Repository
 
on:
  workflow_dispatch:
    inputs:
      restore_mode:
        description: 'Restoration mode'
        required: true
        default: 'incremental'
        type: choice
        options:
        - 'full_reset'
        - 'incremental'
        - 'selective'
      batch_size:
        description: 'Number of modules per batch (for incremental mode)'
        required: false
        default: '20'
        type: string
      modules_pattern:
        description: 'Module pattern for selective restore (e.g., FigureYa1*)'
        required: false
        default: 'FigureYa*'
        type: string
      force_push:
        description: 'Force push (use with caution)'
        required: false
        default: false
        type: boolean
 
permissions:
  contents: read
 
jobs:
  restore:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout backup repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
 
    - name: Setup Git configuration
      run: |
        git config --global user.name "FigureYa Restore Bot"
        git config --global user.email "actions@github.com"
 
    - name: Clone main repository
      run: |
        git clone https://x-access-token:${{ secrets.FIGUREYA2ACTION }}@github.com/${{ github.repository_owner }}/FigureYa.git main-repo
        cd main-repo
        git checkout main || git checkout -b main
        
    - name: Analyze repository sizes
      run: |
        echo "=== Repository Size Analysis ==="
        echo "Backup repo size:"
        du -sh . --exclude=.git --exclude=main-repo
        
        echo "Main repo current size:"
        cd main-repo
        du -sh . --exclude=.git
        cd ..
        
        echo "=== Large Files Detection ==="
        find . -type f -size +50M -not -path "./main-repo/*" -not -path "./.git/*" | head -20
 
    - name: Full Reset Restore
      if: ${{ github.event.inputs.restore_mode == 'full_reset' }}
      run: |
        echo "🔄 Starting full reset restore..."
        cd main-repo
        
        # Create orphan branch for clean start
        git checkout --orphan temp-restore
        git rm -rf . 2>/dev/null || true
        git clean -fd
        
        # Copy essential files first
        echo "📄 Copying essential files..."
        cp ../README.md . 2>/dev/null || echo "# FigureYa" > README.md
        cp ../LICENSE . 2>/dev/null || true
        cp -r ../.github . 2>/dev/null || true
        
        git add .
        git commit -m "Restore: Initial structure"
        
        # Push initial structure
        if [[ "${{ github.event.inputs.force_push }}" == "true" ]]; then
          git push origin temp-restore --force
        else
          git push origin temp-restore
        fi
        
        # Switch main to point to temp-restore
        git checkout temp-restore
        git branch -D main 2>/dev/null || true
        git checkout -b main
        
        echo "✅ Initial structure restored"
 
    - name: Incremental Restore
      if: ${{ github.event.inputs.restore_mode == 'incremental' }}
      run: |
        echo "📦 Starting incremental restore..."
        BATCH_SIZE="${{ github.event.inputs.batch_size }}"
        
        cd main-repo
        
        # Get list of FigureYa modules
        cd ..
        modules=($(ls -d FigureYa*/ 2>/dev/null | head -100))  # Limit to 100 modules
        total_modules=${#modules[@]}
        
        echo "Found $total_modules modules to restore"
        
        cd main-repo
        
        # Process in batches
        for (( i=0; i<$total_modules; i+=$BATCH_SIZE )); do
          batch_num=$((i/$BATCH_SIZE + 1))
          echo "🔄 Processing batch $batch_num..."
          
          # Add modules for this batch
          batch_modules=()
          for (( j=i; j<i+$BATCH_SIZE && j<$total_modules; j++ )); do
            module="${modules[$j]}"
            if [[ -d "../$module" ]]; then
              echo "  Adding $module"
              
              # Create module directory
              mkdir -p "$module"
              
              # Copy only essential files (skip large binaries)
              find "../$module" -name "*.R" -exec cp {} "$module/" \; 2>/dev/null || true
              find "../$module" -name "*.md" -exec cp {} "$module/" \; 2>/dev/null || true
              find "../$module" -name "*.txt" -size -1M -exec cp {} "$module/" \; 2>/dev/null || true
              find "../$module" -name "*.yml" -exec cp {} "$module/" \; 2>/dev/null || true
              find "../$module" -name "*.yaml" -exec cp {} "$module/" \; 2>/dev/null || true
              
              batch_modules+=("$module")
            fi
          done
          
          # Commit this batch
          if [[ ${#batch_modules[@]} -gt 0 ]]; then
            git add "${batch_modules[@]}"
            git commit -m "Restore batch $batch_num: ${batch_modules[*]}"
            
            # Push with retry
            for attempt in 1 2 3; do
              echo "  Attempt $attempt to push batch $batch_num..."
              if git push origin main; then
                echo "  ✅ Batch $batch_num pushed successfully"
                break
              else
                echo "  ⚠️ Push failed, waiting 10 seconds..."
                sleep 10
              fi
            done
          fi
          
          # Brief pause between batches
          sleep 5
        done
 
    - name: Selective Restore
      if: ${{ github.event.inputs.restore_mode == 'selective' }}
      run: |
        echo "🎯 Starting selective restore..."
        PATTERN="${{ github.event.inputs.modules_pattern }}"
        
        cd main-repo
        
        # Find matching modules
        cd ..
        modules=($(ls -d $PATTERN 2>/dev/null))
        
        echo "Found ${#modules[@]} modules matching pattern: $PATTERN"
        
        cd main-repo
        
        for module in "${modules[@]}"; do
          if [[ -d "../$module" ]]; then
            echo "🔄 Restoring $module..."
            
            # Remove existing if present
            rm -rf "$module" 2>/dev/null || true
            
            # Copy module
            cp -r "../$module" .
            
            # Remove large files
            find "$module" -type f -size +10M -delete 2>/dev/null || true
            
            git add "$module"
            git commit -m "Restore: $module"
            git push origin main
            
            sleep 2
          fi
        done
 
    - name: Restore Configuration Files
      run: |
        echo "⚙️ Restoring configuration files..."
        cd main-repo
        
        # Copy documentation
        cp -r ../docs . 2>/dev/null || true
        
        # Copy scripts
        cp -r ../scripts . 2>/dev/null || true
        
        # Update .github workflows (be careful not to overwrite restore workflow)
        if [[ -d "../.github" ]]; then
          mkdir -p .github
          cp -r ../.github/ISSUE_TEMPLATE .github/ 2>/dev/null || true
          cp ../.github/CONTRIBUTING.md .github/ 2>/dev/null || true
          
          # Copy workflows except restore workflow
          if [[ -d "../.github/workflows" ]]; then
            mkdir -p .github/workflows
            for workflow in ../.github/workflows/*.yml ../.github/workflows/*.yaml; do
              if [[ -f "$workflow" ]] && [[ ! "$workflow" =~ restore-to-main ]]; then
                cp "$workflow" .github/workflows/
              fi
            done
          fi
        fi
        
        # Commit configuration files
        git add .
        if ! git diff --staged --quiet; then
          git commit -m "Restore: Configuration and documentation files"
          git push origin main
        fi
 
    - name: Generate Restore Report
      run: |
        echo "📊 Generating restore report..."
        cd main-repo
        
        # Create restore report
        cat > RESTORE_REPORT.md << EOF
        # FigureYa Restore Report
        
        **Restore Date:** $(date)
        **Restore Mode:** ${{ github.event.inputs.restore_mode }}
        **Triggered by:** ${{ github.actor }}
        
        ## Summary
        - **Total modules restored:** $(ls -d FigureYa*/ 2>/dev/null | wc -l)
        - **Repository size:** $(du -sh . --exclude=.git | cut -f1)
        - **Restore duration:** $SECONDS seconds
        
        ## Restored Modules
        \`\`\`
        $(ls -d FigureYa*/ 2>/dev/null | sort)
        \`\`\`
        
        ## Configuration Files
        - README.md: $([ -f README.md ] && echo "✅" || echo "❌")
        - LICENSE: $([ -f LICENSE ] && echo "✅" || echo "❌")
        - .github/workflows: $([ -d .github/workflows ] && echo "✅ ($(ls .github/workflows/*.yml 2>/dev/null | wc -l) files)" || echo "❌")
        - docs/: $([ -d docs ] && echo "✅" || echo "❌")
        
        ## Next Steps
        1. Verify all modules are working correctly
        2. Test key functionality
        3. Update documentation if needed
        4. Set up branch protection rules
        5. Notify team of restoration completion
        
        ---
        *This report was auto-generated by FigureYa Restore Bot*
        EOF
        
        git add RESTORE_REPORT.md
        git commit -m "Add restore report"
        git push origin main
 
    - name: Cleanup and Summary
      run: |
        echo "🧹 Cleanup and summary..."
        
        # Show final status
        cd main-repo
        echo "=== Final Repository Status ==="
        echo "Modules count: $(ls -d FigureYa*/ 2>/dev/null | wc -l)"
        echo "Repository size: $(du -sh . --exclude=.git | cut -f1)"
        echo "Last 5 commits:"
        git log --oneline -5
        
        echo "✅ Restore operation completed successfully!"
